//go:build !abgen_source

// Code generated by abgen. DO NOT EDIT.
// versions: abgen
// source: ../../testdata/03_advanced_features/slice_conversions

package directives

import (
	ent "github.com/origadmin/abgen/testdata/fixtures/ent"
	types "github.com/origadmin/abgen/testdata/fixtures/types"
	time "time"
)

// Local type aliases for external types.
type (
	Resource       = ent.Resource
	ResourceSlice  = types.Resource
	Resources      = []*ent.Resource
	ResourcesSlice = []*types.Resource
	Role           = ent.Role
	RoleSlice      = types.Role
	Roles          = []*ent.Role
	RolesSlice     = []*types.Role
	User           = ent.User
	UserSlice      = types.User
	Users          = []*ent.User
	UsersSlice     = []*types.User
)

// ConvertResourceToResourceSlice converts *[]*ent.Resource to *[]*types.Resource
func ConvertResourceToResourceSlice(from *[]*ent.Resource) *[]*types.Resource {
	if from == nil {
		return nil
	}
	tos := ConvertResourcesToResourcesSlice(*from)
	return &tos
}

// ConvertResourceSliceToResource converts *[]*types.Resource to *[]*ent.Resource
func ConvertResourceSliceToResource(from *[]*types.Resource) *[]*ent.Resource {
	if from == nil {
		return nil
	}
	tos := ConvertResourcesSliceToResources(*from)
	return &tos
}

// ConvertRoleToRoleSlice converts *[]*ent.Role to *[]*types.Role
func ConvertRoleToRoleSlice(from *[]*ent.Role) *[]*types.Role {
	if from == nil {
		return nil
	}
	tos := ConvertRolesToRolesSlice(*from)
	return &tos
}

// ConvertRoleSliceToRole converts *[]*types.Role to *[]*ent.Role
func ConvertRoleSliceToRole(from *[]*types.Role) *[]*ent.Role {
	if from == nil {
		return nil
	}
	tos := ConvertRolesSliceToRoles(*from)
	return &tos
}

// ConvertUserToUserSlice converts *[]*ent.User to *[]*types.User
func ConvertUserToUserSlice(from *[]*ent.User) *[]*types.User {
	if from == nil {
		return nil
	}
	tos := ConvertUsersToUsersSlice(*from)
	return &tos
}

// ConvertUserSliceToUser converts *[]*types.User to *[]*ent.User
func ConvertUserSliceToUser(from *[]*types.User) *[]*ent.User {
	if from == nil {
		return nil
	}
	tos := ConvertUsersSliceToUsers(*from)
	return &tos
}

// ConvertResourceToResourceSlice converts *[]*ent.Resource to *[]*types.Resource
func ConvertResourceToResourceSlice(from *[]*ent.Resource) *[]*types.Resource {
	if from == nil {
		return nil
	}
	tos := ConvertResourcesToResourcesSlice(*from)
	return &tos
}

// ConvertResourceSliceToResource converts *[]*types.Resource to *[]*ent.Resource
func ConvertResourceSliceToResource(from *[]*types.Resource) *[]*ent.Resource {
	if from == nil {
		return nil
	}
	tos := ConvertResourcesSliceToResources(*from)
	return &tos
}

// ConvertRoleToRoleSlice converts *[]*ent.Role to *[]*types.Role
func ConvertRoleToRoleSlice(from *[]*ent.Role) *[]*types.Role {
	if from == nil {
		return nil
	}
	tos := ConvertRolesToRolesSlice(*from)
	return &tos
}

// ConvertRoleSliceToRole converts *[]*types.Role to *[]*ent.Role
func ConvertRoleSliceToRole(from *[]*types.Role) *[]*ent.Role {
	if from == nil {
		return nil
	}
	tos := ConvertRolesSliceToRoles(*from)
	return &tos
}

// ConvertUserToUserSlice converts *[]*ent.User to *[]*types.User
func ConvertUserToUserSlice(from *[]*ent.User) *[]*types.User {
	if from == nil {
		return nil
	}
	tos := ConvertUsersToUsersSlice(*from)
	return &tos
}

// ConvertUserSliceToUser converts *[]*types.User to *[]*ent.User
func ConvertUserSliceToUser(from *[]*types.User) *[]*ent.User {
	if from == nil {
		return nil
	}
	tos := ConvertUsersSliceToUsers(*from)
	return &tos
}

// ConvertResourcesToResourcesSlice converts Resources to ResourcesSlice
func ConvertResourcesToResourcesSlice(froms Resources) ResourcesSlice {
	if froms == nil {
		return nil
	}
	tos := make(ResourcesSlice, len(froms))
	for i, f := range froms {
		tmp := ConvertResourcesToResourcesSlice(f)
		tos[i] = &tmp
	}
	return tos
}

// ConvertResourcesSliceToResources converts ResourcesSlice to Resources
func ConvertResourcesSliceToResources(froms ResourcesSlice) Resources {
	if froms == nil {
		return nil
	}
	tos := make(Resources, len(froms))
	for i, f := range froms {
		tmp := ConvertResourcesSliceToResources(f)
		tos[i] = &tmp
	}
	return tos
}

// ConvertRolesToRolesSlice converts Roles to RolesSlice
func ConvertRolesToRolesSlice(froms Roles) RolesSlice {
	if froms == nil {
		return nil
	}
	tos := make(RolesSlice, len(froms))
	for i, f := range froms {
		tmp := ConvertRolesToRolesSlice(f)
		tos[i] = &tmp
	}
	return tos
}

// ConvertRolesSliceToRoles converts RolesSlice to Roles
func ConvertRolesSliceToRoles(froms RolesSlice) Roles {
	if froms == nil {
		return nil
	}
	tos := make(Roles, len(froms))
	for i, f := range froms {
		tmp := ConvertRolesSliceToRoles(f)
		tos[i] = &tmp
	}
	return tos
}

// ConvertUsersToUsersSlice converts Users to UsersSlice
func ConvertUsersToUsersSlice(froms Users) UsersSlice {
	if froms == nil {
		return nil
	}
	tos := make(UsersSlice, len(froms))
	for i, f := range froms {
		tmp := ConvertUsersToUsersSlice(f)
		tos[i] = &tmp
	}
	return tos
}

// ConvertUsersSliceToUsers converts UsersSlice to Users
func ConvertUsersSliceToUsers(froms UsersSlice) Users {
	if froms == nil {
		return nil
	}
	tos := make(Users, len(froms))
	for i, f := range froms {
		tmp := ConvertUsersSliceToUsers(f)
		tos[i] = &tmp
	}
	return tos
}

// ConvertResourcesToResourcesSlice converts Resources to ResourcesSlice
func ConvertResourcesToResourcesSlice(froms Resources) ResourcesSlice {
	if froms == nil {
		return nil
	}
	tos := make(ResourcesSlice, len(froms))
	for i, f := range froms {
		tos[i] = ConvertResourceToResourceSlice(f)
	}
	return tos
}

// ConvertResourcesSliceToResources converts ResourcesSlice to Resources
func ConvertResourcesSliceToResources(froms ResourcesSlice) Resources {
	if froms == nil {
		return nil
	}
	tos := make(Resources, len(froms))
	for i, f := range froms {
		tos[i] = ConvertResourceSliceToResource(f)
	}
	return tos
}

// ConvertRolesToRolesSlice converts Roles to RolesSlice
func ConvertRolesToRolesSlice(froms Roles) RolesSlice {
	if froms == nil {
		return nil
	}
	tos := make(RolesSlice, len(froms))
	for i, f := range froms {
		tos[i] = ConvertRoleToRoleSlice(f)
	}
	return tos
}

// ConvertRolesSliceToRoles converts RolesSlice to Roles
func ConvertRolesSliceToRoles(froms RolesSlice) Roles {
	if froms == nil {
		return nil
	}
	tos := make(Roles, len(froms))
	for i, f := range froms {
		tos[i] = ConvertRoleSliceToRole(f)
	}
	return tos
}

// ConvertUsersToUsersSlice converts Users to UsersSlice
func ConvertUsersToUsersSlice(froms Users) UsersSlice {
	if froms == nil {
		return nil
	}
	tos := make(UsersSlice, len(froms))
	for i, f := range froms {
		tos[i] = ConvertUserToUserSlice(f)
	}
	return tos
}

// ConvertUsersSliceToUsers converts UsersSlice to Users
func ConvertUsersSliceToUsers(froms UsersSlice) Users {
	if froms == nil {
		return nil
	}
	tos := make(Users, len(froms))
	for i, f := range froms {
		tos[i] = ConvertUserSliceToUser(f)
	}
	return tos
}

// ConvertResourceToResourceSlice converts Resource to ResourceSlice
func ConvertResourceToResourceSlice(from *Resource) *ResourceSlice {
	if from == nil {
		return nil
	}

	to := &types.Resource{
		Id:       from.ID,
		Name:     from.Name,
		ParentId: from.ParentID,
	}
	return to
}

// ConvertResourceSliceToResource converts ResourceSlice to Resource
func ConvertResourceSliceToResource(from *ResourceSlice) *Resource {
	if from == nil {
		return nil
	}

	to := &ent.Resource{
		ID:       from.Id,
		Name:     from.Name,
		ParentID: from.ParentId,
	}
	return to
}

// ConvertRoleToRoleSlice converts Role to RoleSlice
func ConvertRoleToRoleSlice(from *Role) *RoleSlice {
	if from == nil {
		return nil
	}

	to := &types.Role{
		Id:   from.ID,
		Name: from.Name,
	}
	return to
}

// ConvertRoleSliceToRole converts RoleSlice to Role
func ConvertRoleSliceToRole(from *RoleSlice) *Role {
	if from == nil {
		return nil
	}

	to := &ent.Role{
		ID:   from.Id,
		Name: from.Name,
	}
	return to
}

// ConvertUserToUserSlice converts User to UserSlice
func ConvertUserToUserSlice(from *User) *UserSlice {
	if from == nil {
		return nil
	}

	to := &types.User{
		Id:        from.ID,
		Username:  from.Username,
		Age:       from.Age,
		Gender:    ConvertGenderToGenderSlice(from.Gender),
		CreatedAt: ConvertTimeToString(from.CreatedAt),
		Status:    ConvertUserStatusToUserSliceStatus(from.Status),
	}
	return to
}

// ConvertUserSliceToUser converts UserSlice to User
func ConvertUserSliceToUser(from *UserSlice) *User {
	if from == nil {
		return nil
	}

	to := &ent.User{
		ID:        from.Id,
		Username:  from.Username,
		Age:       from.Age,
		Gender:    ConvertGenderSliceToGender(from.Gender),
		Status:    ConvertUserSliceStatusToUserStatus(from.Status),
		CreatedAt: ConvertStringToTime(from.CreatedAt),
	}
	return to
}

// --- Helper Functions ---

func ConvertStringToTime(s string) time.Time {
	t, _ := time.Parse(time.RFC3339, s)
	return t
}

func ConvertTimeToString(t time.Time) string {
	return t.Format(time.RFC3339)
}
