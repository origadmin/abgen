/*
 * Copyright (c) 2024 OrigAdmin. All rights reserved.
 */

package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/token"
	"log"
	"log/slog"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

// ConversionConfig 转换配置
type ConversionConfig struct {
	SourceType   string
	TargetType   string
	Direction    string // both/to/from
	IgnoreFields map[string]bool
}

// ConversionGraph 类型转换关系图
type ConversionGraph map[string]*ConversionNode

// ConversionNode 类型转换节点
type ConversionNode struct {
	FromConversions []string // 该类型可作为源类型的转换目标
	ToConversions   []string // 该类型可作为目标类型的来源
	Configs         map[string]*ConversionConfig
}

// ConverterGenerator 代码生成器
type ConverterGenerator struct {
	Imports        map[string]string
	Graph          ConversionGraph
	TypeMap        map[string]string // 类型映射 time.Time -> timestamppb.Timestamp
	PkgPath        string
	Output         string
	parsedPackages []*packages.Package
	typeCache      map[string]TypeInfo
}

type TypeInfo struct {
	Name       string
	ImportPath string
	Fields     []StructField
}

type StructField struct {
	Name     string
	Type     string
	Exported bool
}

const converterTemplate = `
// Code generated by alias-binding. DO NOT EDIT.

package {{.Package}}

{{range $key, $val := .Imports}}
import {{$key}} "{{$val}}"
{{end}}

{{range .Converters}}
// {{.FuncName}} 自动生成的转换方法
func {{.FuncName}}(src *{{.SourceType}}) *{{.TargetType}} {
	dst := &{{.TargetType}}{}
	if src == nil {
		return dst
	}
	
	{{range .Fields -}} 
	{{if .Ignore}}// ignore: {{.Name}} {{.IgnoreReason}}
	{{else}}{{.Conversion}}
	{{end -}} 
	{{end}}
	return dst
}
{{end}}
`

func main() {
	flag.Parse()
	args := flag.Args()
	if len(args) != 1 {
		log.Fatal("Usage: converter gen <directory>")
	}

	generator := NewConverterGenerator()
	generator.Output = args[0]

	if err := generator.ParseDir(args[0]); err != nil {
		log.Fatal(err)
	}
	if err := generator.Validate(); err != nil {
		log.Fatal(err)
	}
	if err := generator.Generate(); err != nil {
		log.Fatal(err)
	}
}

func NewConverterGenerator() *ConverterGenerator {
	return &ConverterGenerator{
		Graph: make(ConversionGraph),
		TypeMap: map[string]string{
			"time.Time":              "timestamppb.Timestamp",
			"timestamppb.Timestamp":  "time.Time",
			"[]byte":                 "[]byte",
			"map[string]interface{}": "*structpb.Struct",
			"*structpb.Struct":       "map[string]interface{}",
		},
		typeCache: make(map[string]TypeInfo), // 添加初始化
	}
}

func (g *ConverterGenerator) resolveType(typeName string) (TypeInfo, error) {
	slog.Info("解析类型", "类型名", typeName)
	// 处理带包前缀的类型 (如ent.User)
	parts := strings.Split(typeName, ".")
	if len(parts) > 1 {
		pkgAlias := parts[0]
		typeName := parts[1]
		return g.resolveImportedType(pkgAlias, typeName)
	}
	// 处理当前包类型
	return g.resolveLocalType(typeName)
}

func (g *ConverterGenerator) resolveImportedType(pkgAlias, typeName string) (TypeInfo, error) {
	// 查找导入路径
	impPath, ok := g.Imports[pkgAlias]
	if !ok {
		return TypeInfo{}, fmt.Errorf("package %s not imported", pkgAlias)
	}

	// 加载目标包
	pkg, err := g.loadPackage(impPath)
	if err != nil {
		return TypeInfo{}, fmt.Errorf("加载包失败: %w", err)
	}

	var foundType *ast.TypeSpec
	packages.Visit([]*packages.Package{pkg}, func(p *packages.Package) bool {
		for _, f := range p.Syntax {
			for _, decl := range f.Decls {
				genDecl, ok := decl.(*ast.GenDecl)
				if !ok || genDecl.Tok != token.TYPE {
					continue
				}

				for _, spec := range genDecl.Specs {
					typeSpec := spec.(*ast.TypeSpec)
					if typeSpec.Name.Name == typeName {
						foundType = typeSpec
						return false // 终止遍历
					}
				}
			}
		}
		return true
	}, nil)

	if foundType == nil {
		return TypeInfo{}, fmt.Errorf("类型 %s 未在包 %s 中找到", typeName, impPath)
	}

	// 处理类型别名和结构体
	if foundType.Assign != 0 {
		// 处理类型别名（type T = other.Type）
		targetType := g.exprToString(foundType.Type)
		log.Printf("发现类型别名: %s.%s => %s", pkgAlias, typeName, targetType)
		return g.resolveType(targetType) // 递归解析
	}

	// 处理结构体类型
	if _, ok := foundType.Type.(*ast.StructType); ok {
		return g.parseStructType(foundType, impPath)
	}

	// 处理其他类型声明
	return TypeInfo{
		Name:       typeName,
		ImportPath: impPath,
		Fields:     []StructField{}, // 非结构体类型无字段
	}, nil
}

// 在ConverterGenerator中添加
func (g *ConverterGenerator) parseStructType(typeSpec *ast.TypeSpec, impPath string) (TypeInfo, error) {
	info := TypeInfo{
		Name:       typeSpec.Name.Name,
		ImportPath: impPath,
	}

	structType, ok := typeSpec.Type.(*ast.StructType)
	if !ok {
		return info, fmt.Errorf("%s is not a struct type", typeSpec.Name.Name)
	}

	for _, field := range structType.Fields.List {
		// 跳过匿名字段
		if len(field.Names) == 0 {
			continue
		}

		fieldName := field.Names[0].Name
		if !ast.IsExported(fieldName) {
			continue
		}
		fieldType := g.exprToString(field.Type)

		info.Fields = append(info.Fields, StructField{
			Name:     fieldName,
			Type:     fieldType,
			Exported: true,
		})
	}
	return info, nil
}

// 添加表达式解析方法
func (g *ConverterGenerator) exprToString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return g.exprToString(t.X) + "." + t.Sel.Name
	case *ast.StarExpr:
		return "*" + g.exprToString(t.X)
	case *ast.ArrayType:
		return "[]" + g.exprToString(t.Elt)
	case *ast.MapType:
		return fmt.Sprintf("map[%s]%s",
			g.exprToString(t.Key),
			g.exprToString(t.Value))
	case *ast.InterfaceType:
		return "interface{}"
	case *ast.StructType:
		return "struct{}"
	default:
		return fmt.Sprintf("%T", expr)
	}
}

// 添加本地类型解析方法
func (g *ConverterGenerator) resolveLocalType(typeName string) (TypeInfo, error) {
	log.Printf("Show all types in cache: %v", g.typeCache)
	// 先检查缓存
	if info, ok := g.typeCache[typeName]; ok {
		return info, nil
	}

	// 添加本地类型解析逻辑
	for _, pkg := range g.parsedPackages {
		for _, f := range pkg.Syntax {
			for _, decl := range f.Decls {
				genDecl, ok := decl.(*ast.GenDecl)
				if !ok || genDecl.Tok != token.TYPE {
					continue
				}

				for _, spec := range genDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok || typeSpec.Name.Name != typeName {
						continue
					}

					// 解析类型并缓存
					info, err := g.parseTypeSpec(typeSpec, "")
					if err != nil {
						return TypeInfo{}, err
					}

					g.typeCache[typeName] = info
					return info, nil
				}
			}
		}
	}
	return TypeInfo{}, fmt.Errorf("local type %s not found", typeName)
}

// 添加通用类型解析方法
func (g *ConverterGenerator) parseTypeSpec(typeSpec *ast.TypeSpec, impPath string) (TypeInfo, error) {
	info := TypeInfo{
		Name:       typeSpec.Name.Name,
		ImportPath: impPath,
	}

	// 处理类型别名（type Alias = TargetType）
	if typeSpec.Assign != 0 {
		// 递归解析目标类型
		targetType := g.exprToString(typeSpec.Type)
		resolved, err := g.resolveType(targetType)
		if err != nil {
			return info, fmt.Errorf("解析类型别名失败: %w", err)
		}

		// 继承目标类型的字段
		info.Fields = resolved.Fields
		info.ImportPath = resolved.ImportPath
		return info, nil
	}

	// 原有处理逻辑保持不变...
	// 处理结构体类型
	if structType, ok := typeSpec.Type.(*ast.StructType); ok {
		for _, field := range structType.Fields.List {
			if len(field.Names) == 0 {
				continue
			}

			fieldName := field.Names[0].Name
			info.Fields = append(info.Fields, StructField{
				Name:     fieldName,
				Type:     g.exprToString(field.Type),
				Exported: ast.IsExported(fieldName),
			})
		}
		return info, nil
	}

	// 修改基础类型别名的处理方式
	if ident, ok := typeSpec.Type.(*ast.Ident); ok {
		// 如果是基础类型别名（如 type MyInt = int）
		resolved, err := g.resolveType(ident.Name)
		if err == nil {
			info.Fields = resolved.Fields
		} else {
			// 基础类型没有字段
			info.Fields = []StructField{}
		}
		return info, nil
	}

	// 处理选择器表达式（跨包别名）
	if sel, ok := typeSpec.Type.(*ast.SelectorExpr); ok {
		targetType := g.exprToString(sel)
		resolved, err := g.resolveType(targetType)
		if err != nil {
			return info, err
		}
		info.Fields = resolved.Fields
		info.ImportPath = resolved.ImportPath
		return info, nil
	}

	return info, fmt.Errorf("unsupported type: %T", typeSpec.Type)
}

func (g *ConverterGenerator) generateFieldConversion(name, srcType, dstType, srcName string,
	cfg *ConversionConfig) (string, error) {
	// 基本类型转换
	if g.isPrimitiveType(srcType) && g.isPrimitiveType(dstType) {
		return g.primitiveConversion(name, srcType, dstType, srcName)
	}

	// 时间类型处理
	if srcType == "time.Time" && dstType == "*timestamppb.Timestamp" {
		return fmt.Sprintf("dst.%s = timestamppb.New(src.%s)", name, name), nil
	}

	if srcType == "*timestamppb.Timestamp" && dstType == "time.Time" {
		return fmt.Sprintf("dst.%s = src.%s.AsTime()", name, name), nil
	}

	// 嵌套结构转换
	if strings.HasPrefix(srcType, "*") && strings.HasPrefix(dstType, "*") {
		return g.structConversion(name, srcType, dstType, srcName)
	}

	// slice类型处理
	if strings.HasPrefix(srcType, "[]") && strings.HasPrefix(dstType, "[]") {
		return g.sliceConversion(name, srcType, dstType)
	}
	log.Printf("未处理的字段转换: %s -> %s", srcType, dstType)
	return fmt.Sprintf("// 未处理的字段转换: %s -> %s", srcType, dstType), nil
}

func (g *ConverterGenerator) structConversion(dstFieldName, srcType, dstType, srcFieldName string) (string, error) {
	srcElem := strings.TrimPrefix(srcType, "*")
	dstElem := strings.TrimPrefix(dstType, "*")
	return fmt.Sprintf("dst.%s = Convert%sTo%s(src.%s)",
			dstFieldName, // 使用目标字段名
			srcElem,
			dstElem,
			srcFieldName), // 保留源字段名
		nil
}

func (g *ConverterGenerator) sliceConversion(name, srcType, dstType string) (string, error) {
	srcElem := strings.TrimPrefix(srcType, "[]")
	dstElem := strings.TrimPrefix(dstType, "[]")
	return fmt.Sprintf(`
for _, v := range src.%s {
    dst.%s = append(dst.%s, Convert%sTo%s(v))
}`, name, name, name, srcElem, dstElem), nil
}
func (g *ConverterGenerator) loadPackage(importPath string) (*packages.Package, error) {
	// 使用go/packages加载包信息
	cfg := &packages.Config{
		Mode: packages.NeedSyntax | packages.NeedName | packages.NeedFiles |
			packages.NeedCompiledGoFiles | packages.NeedImports |
			packages.NeedTypes | packages.NeedTypesInfo,
	}
	pkgs, err := packages.Load(cfg, importPath)
	if err != nil {
		return nil, err
	}
	return pkgs[0], nil
}

func (g *ConverterGenerator) ParseDir(dir string) error {
	cfg := &packages.Config{
		Mode: packages.NeedSyntax | packages.NeedName | packages.NeedFiles |
			packages.NeedCompiledGoFiles | packages.NeedImports |
			packages.NeedTypes | packages.NeedTypesInfo,
	}
	pkgs, err := packages.Load(cfg, dir)
	if err != nil {
		return err
	}
	g.parsedPackages = pkgs
	for _, pkg := range pkgs {
		log.Printf("Parsing package: %s", pkg.PkgPath)
		for _, file := range pkg.Syntax {
			if pkg.Fset == nil || file == nil {
				continue
			}

			offset := pkg.Fset.File(file.Pos())
			if offset == nil {
				continue
			}
			filename := offset.Name()
			log.Printf("Parsing file: %s", filename)
			if filepath.Base(filename) == "converter.gen.go" {
				continue
			}

			if err := g.processFile(file); err != nil {
				return err
			}
		}
	}
	return nil
}

func (g *ConverterGenerator) processFile(f *ast.File) error {
	log.Printf("正在处理文件: %v", f.Name)
	g.Imports = make(map[string]string)
	for _, imp := range f.Imports {
		alias := ""
		if imp.Name != nil {
			alias = imp.Name.Name
		} else {
			// 自动获取包别名
			parts := strings.Split(strings.Trim(imp.Path.Value, `"`), "/")
			alias = parts[len(parts)-1]
		}
		g.Imports[alias] = strings.Trim(imp.Path.Value, `"`)
	}

	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}
		log.Printf("正在处理类型声明: %+v", genDecl)

		for _, spec := range genDecl.Specs {
			if typeSpec, ok := spec.(*ast.TypeSpec); ok {
				log.Printf("发现类型定义: %s", typeSpec.Name.Name)
				if typeSpec.Doc != nil {
					for _, comment := range typeSpec.Doc.List {
						log.Printf("类型定义文档: %+v", comment.Text)
					}

				}
				cfg := g.parseCommentGroup(typeSpec.Name.Name, typeSpec.Doc)
				if cfg != nil {
					log.Printf("解析到转换配置: %s -> %s (方向: %s)",
						cfg.SourceType, cfg.TargetType, cfg.Direction)
					g.addToGraph(cfg)
				}
			}

			if valueSpec, ok := spec.(*ast.ValueSpec); ok && len(valueSpec.Names) > 0 {
				log.Printf("发现声明定义: %s", valueSpec.Names[0].Name)
				cfg := g.parseCommentGroup(valueSpec.Names[0].Name, valueSpec.Doc)
				if cfg != nil {
					log.Printf("找到值声明转换配置: %+v", cfg)
					g.addToGraph(cfg)
				}
			}

		}
	}
	return nil
}

func (g *ConverterGenerator) parseCommentGroup(typeName string, doc *ast.CommentGroup) *ConversionConfig {
	if doc == nil {
		log.Printf("类型 %s 没有关联的注释", typeName)
		return nil
	}

	var cfg ConversionConfig
	// 合并所有注释内容
	fullComment := ""
	for _, comment := range doc.List {
		fullComment += strings.TrimSpace(strings.TrimPrefix(comment.Text, "//")) + "\n"
	}
	log.Printf("正在解析注释: %s", fullComment)
	if !strings.Contains(fullComment, "@Convert") {
		return nil
	}

	params := parseCommentParams(fullComment)
	log.Printf("解析到参数: %+v", params) // 新增调试日志

	cfg.SourceType = typeName
	cfg.TargetType = strings.Trim(params["target"], "\"")
	cfg.Direction = strings.Trim(params["direction"], "\"")
	if cfg.Direction == "" {
		cfg.Direction = "both"
	}
	cfg.IgnoreFields = make(map[string]bool)
	if fields, ok := params["ignoreFields"]; ok {
		for _, f := range strings.Split(fields, ",") {
			cfg.IgnoreFields[strings.TrimSpace(f)] = true
		}
	}
	return &cfg
}

func parseCommentParams(comment string) map[string]string {
	params := make(map[string]string)
	// 合并多行注释为单行
	singleLine := strings.ReplaceAll(comment, "\n", " ")
	// 增强正则表达式，支持以下形式：
	// 1. target="UserPB"
	// 2. target = "UserPB"
	// 3. target=UserPB
	// 4. ignoreFields=["password","salt"]
	re := regexp.MustCompile(`(\w+)\s*=\s*(\[[^\]]+\]|"[^"]+"|'[^']+'|\S+)`)
	matches := re.FindAllStringSubmatch(singleLine, -1)

	for _, m := range matches {
		if m[1] != "" { // 处理数组参数
			params[m[1]] = strings.TrimSpace(m[2])
		} else if m[3] != "" { // 处理普通参数
			params[m[3]] = m[4]
		}
	}
	return params
}

func (g *ConverterGenerator) addToGraph(cfg *ConversionConfig) {
	// 添加源类型节点
	if _, exists := g.Graph[cfg.SourceType]; !exists {
		g.Graph[cfg.SourceType] = &ConversionNode{
			Configs: make(map[string]*ConversionConfig),
		}
	}
	g.Graph[cfg.SourceType].Configs[cfg.TargetType] = cfg

	// 添加目标类型节点
	if _, exists := g.Graph[cfg.TargetType]; !exists {
		g.Graph[cfg.TargetType] = &ConversionNode{
			Configs: make(map[string]*ConversionConfig),
		}
	}

	// 构建双向关系
	if cfg.Direction == "both" || cfg.Direction == "to" {
		g.Graph[cfg.SourceType].FromConversions = append(
			g.Graph[cfg.SourceType].FromConversions,
			cfg.TargetType,
		)
		g.Graph[cfg.TargetType].ToConversions = append(
			g.Graph[cfg.TargetType].ToConversions,
			cfg.SourceType,
		)
	}
}

func (g *ConverterGenerator) Validate() error {
	for source, node := range g.Graph {
		for _, target := range node.FromConversions {
			targetNode, exists := g.Graph[target]
			if !exists {
				return fmt.Errorf("target type %s not found for %s", target, source)
			}

			if !contains(targetNode.ToConversions, source) {
				return fmt.Errorf("missing reciprocal conversion from %s to %s", target, source)
			}
		}
	}
	return nil
}

// 在ConverterGenerator中添加
func (g *ConverterGenerator) isPrimitiveType(t string) bool {
	primitiveTypes := map[string]bool{
		"bool":   true,
		"string": true,
		"int":    true, "int8": true, "int16": true, "int32": true, "int64": true,
		"uint": true, "uint8": true, "uint16": true, "uint32": true, "uint64": true,
		"float32": true, "float64": true,
		"byte": true, "rune": true,
	}
	return primitiveTypes[t]
}

func (g *ConverterGenerator) primitiveConversion(fieldName, srcType, dstType, srcName string) (string, error) {
	if srcType == dstType {
		// 类型相同直接赋值
		return fmt.Sprintf("dst.%s = src.%s", fieldName, srcName), nil
	}

	// 处理数字类型转换
	if isNumberType(srcType) && isNumberType(dstType) {
		return fmt.Sprintf("dst.%s = %s(src.%s)", fieldName, dstType, fieldName), nil
	}

	// 处理其他可转换的基本类型
	switch {
	case srcType == "string" && dstType == "[]byte":
		return fmt.Sprintf("dst.%s = []byte(src.%s)", fieldName, fieldName), nil
	case srcType == "[]byte" && dstType == "string":
		return fmt.Sprintf("dst.%s = string(src.%s)", fieldName, fieldName), nil
	default:
		return "", fmt.Errorf("incompatible primitive types: %s -> %s", srcType, dstType)
	}
}

// 辅助函数判断是否是数字类型
func isNumberType(t string) bool {
	numberTypes := map[string]bool{
		"int": true, "int8": true, "int16": true, "int32": true, "int64": true,
		"uint": true, "uint8": true, "uint16": true, "uint32": true, "uint64": true,
		"float32": true, "float64": true,
	}
	return numberTypes[t]
}
func (g *ConverterGenerator) Generate() error {
	tmpl, err := template.New("converter").Parse(converterTemplate)
	if err != nil {
		return err
	}

	var data struct {
		Package    string
		Imports    map[string]string
		Converters []map[string]interface{}
	}
	data.Package = g.parsedPackages[0].Name
	// 生成转换器数据
	log.Println("======== 转换配置汇总 ========")
	for source, node := range g.Graph {
		for target, cfg := range node.Configs {
			log.Printf("转换对: %s -> %s", source, target)
			log.Printf("配置详情: %+v", cfg)
			converter := map[string]interface{}{
				"FuncName":   fmt.Sprintf("Convert%sTo%s", source, target),
				"SourceType": source,
				"TargetType": target,
				"Fields":     g.generateFieldConversions(source, target, cfg),
			}
			data.Converters = append(data.Converters, converter)
		}
	}
	log.Println("======== 类型解析测试 ========")
	testTypes := []string{"time.Time", "timestamppb.Timestamp"}
	for _, t := range testTypes {
		if _, err := g.resolveType(t); err != nil {
			log.Printf("类型解析失败: %s => %v", t, err)
		}
	}

	// 调试模板数据
	log.Println("======== 模板数据 ========")
	log.Printf("Package: %s", data.Package)
	log.Printf("Imports: %+v", data.Imports)
	log.Printf("Converters 数量: %d", len(data.Converters))
	// 写入文件
	if strings.HasSuffix(g.Output, ".go") {
		g.Output = filepath.Dir(g.Output)
	}
	output, err := os.Create(filepath.Join(g.Output, "converter.gen.go"))
	if err != nil {
		return err
	}
	defer output.Close()

	return tmpl.Execute(output, data)
}

// 在ConverterGenerator中添加
func (g *ConverterGenerator) generateFieldConversions(sourceType, targetType string, cfg *ConversionConfig) []map[string]interface{} {
	log.Printf("生成字段转换: %s -> %s", sourceType, targetType)
	var fields []map[string]interface{}

	// 获取源类型结构信息
	srcInfo, err := g.resolveType(sourceType)
	if err != nil {
		log.Fatalf("解析源类型失败: %v", err)
	}

	// 获取目标类型结构信息
	dstInfo, err := g.resolveType(targetType)
	if err != nil {
		log.Fatalf("解析目标类型失败: %v", err)
	}
	log.Printf("源类型字段数: %d", len(srcInfo.Fields))
	log.Printf("目标类型字段数: %d", len(dstInfo.Fields))
	// 创建目标字段映射表（字段名 -> 类型）
	dstFieldMap := make(map[string]struct {
		OriginalName string
		Type         string
	})
	for _, f := range dstInfo.Fields {
		lowerName := strings.ToLower(f.Name)
		dstFieldMap[lowerName] = struct {
			OriginalName string
			Type         string
		}{f.Name, f.Type}
	}

	// 遍历源结构字段
	for _, srcField := range srcInfo.Fields {

		// 检查是否被忽略
		if cfg.IgnoreFields[srcField.Name] {
			log.Printf("字段 %s 被忽略", srcField.Name)
			fields = append(fields, map[string]interface{}{
				"Name":       srcField.Name,
				"Ignore":     true,
				"Conversion": "",
			})
			continue
		}

		// 转换为小写进行匹配
		lowerSrcName := strings.ToLower(srcField.Name)
		log.Printf("处理字段: %s (%s)", srcField.Name, srcField.Type)
		// 查找目标字段
		dstField, exists := dstFieldMap[lowerSrcName]
		if !exists {
			log.Printf("字段不匹配: %s 不存在于 %s", srcField.Name, targetType)
			continue
		}

		// 生成转换逻辑
		conversion, err := g.generateFieldConversion(
			dstField.OriginalName,
			srcField.Type,
			dstField.Type,
			srcField.Name,
			cfg,
		)
		if err != nil {
			log.Fatalf("生成字段转换失败: %v", err)
		}

		fields = append(fields, map[string]interface{}{
			"Name":       srcField.Name,
			"Ignore":     false,
			"Conversion": conversion,
		})
	}

	return fields
}

func (g *ConverterGenerator) getConversionLogic(fieldName, srcType, targetType string) string {
	// 根据类型映射生成转换逻辑
	switch {
	case strings.HasPrefix(srcType, "[]"):
		elemType := strings.TrimPrefix(srcType, "[]")
		targetElem := g.TypeMap[elemType]
		return fmt.Sprintf("for _, v := range src.%s { dst.%s = append(dst.%s, Convert%sTo%s(v)) }",
			fieldName, fieldName, fieldName, elemType, targetElem)
	case srcType == "time.Time":
		return fmt.Sprintf("dst.%s = timestamppb.New(src.%s)", fieldName, fieldName)
	case g.TypeMap[srcType] != "":
		return fmt.Sprintf("dst.%s = %s(src.%s)", fieldName, g.TypeMap[srcType], fieldName)
	default:
		return fmt.Sprintf("dst.%s = src.%s", fieldName, fieldName)
	}
}

// Helper functions
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}
