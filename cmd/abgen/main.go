package main

import (
	"flag"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"

	goversion "github.com/caarlos0/go-version"
	"golang.org/x/tools/go/packages"

	"github.com/origadmin/abgen/internal/ast"
	"github.com/origadmin/abgen/internal/generator"
	"github.com/origadmin/abgen/internal/types"
)

var (
	version   = "0.0.1"
	commit    = ""
	treeState = ""
	date      = ""
	builtBy   = ""
	debug     = flag.Bool("debug", false, "Enable debug logging")
	output    = flag.String("output", "", "Output file name. Defaults to generating a file in the source directory.")
)

func main() {
	flag.Parse()

	logLevel := slog.LevelInfo
	if *debug {
		logLevel = slog.LevelDebug
	}

	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: logLevel,
	})))

	if len(flag.Args()) == 0 {
		v := buildVersion(version, commit, date, builtBy, treeState)
		fmt.Println(v.String())
		fmt.Println("Usage: abgen [options] <source_directory>")
		flag.PrintDefaults()
		return
	}

	sourceDir := flag.Arg(0)
	slog.Info("Starting abgen", "sourceDir", sourceDir)

	// --- 1. Load Packages ---
	slog.Debug("Loading packages...")
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedImports | packages.NeedDeps,
		// Note: We intentionally exclude packages.NeedTypes | packages.NeedTypesInfo 
		// to avoid type checking errors for types that will be generated by abgen
		Dir: sourceDir,
		// Allow parsing packages with type errors since we may generate the missing types
		//AllowErrors: true,
	}
	initialPkgs, err := packages.Load(cfg, ".")
	if err != nil {
		slog.Error("Failed to load initial package", "error", err)
		os.Exit(1)
	}
	// Note: We don't exit on type errors since abgen may generate the missing types
	// However, we still log them for debugging
	errorCount := packages.PrintErrors(initialPkgs)
	if errorCount > 0 {
		slog.Warn("Type errors found in initial package (expected for types that will be generated)", "errorCount", errorCount)
	}
	if len(initialPkgs) == 0 {
		slog.Error("No packages found in source directory", "sourceDir", sourceDir)
		os.Exit(1)
	}
	directivePkg := initialPkgs[0]

	// --- 2. Create and Run Walker ---
	slog.Debug("Initializing walker and analysis...")
	walker := ast.NewPackageWalker()

	// First, discover any paired packages from directives
	discoveredPaths, err := walker.DiscoverPackages(directivePkg)
	if err != nil {
		slog.Error("Failed to discover packages from directives", "error", err)
		os.Exit(1)
	}

	// Load all necessary packages (initial + discovered)
	// For the full load, we need type information, so we create a separate config
	fullCfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedImports | packages.NeedDeps,
		Dir:  sourceDir,
		//AllowErrors: true, // Still allow errors for the directive package
	}
	allLoadPatterns := append([]string{"."}, discoveredPaths...)
	allPkgs, err := packages.Load(fullCfg, allLoadPatterns...)
	if err != nil {
		slog.Error("Failed to load all required packages", "error", err)
		os.Exit(1)
	}
	// Check for critical errors (excluding the directive package type errors)
	if packages.PrintErrors(allPkgs) > 0 {
		slog.Warn("Some packages have type errors (this may be expected for types that abgen will generate)")
	}

	// Give all loaded packages to the walker
	walker.AddPackages(allPkgs...)

	// Run the full analysis
	if err := walker.Analyze(directivePkg); err != nil {
		slog.Error("Analysis failed", "error", err)
		os.Exit(1)
	}
	slog.Info("Analysis complete.")

	// --- 3. Generate Code ---
	slog.Debug("Generating code...")
	g := generator.NewGenerator(walker)
	generatedCode, err := g.Generate()
	if err != nil {
		slog.Error("Code generation failed", "error", err)
		os.Exit(1)
	}

	// --- 4. Write Output ---
	outputFile := *output
	if outputFile == "" {
		// Default to <pkg_name>.abgen.go in the source directory
		outputFile = filepath.Join(sourceDir, directivePkg.Name+"_abgen.go")
	}

	slog.Info("Writing generated code", "file", outputFile)
	err = os.WriteFile(outputFile, generatedCode, 0644)
	if err != nil {
		slog.Error("Failed to write output file", "error", err)
		os.Exit(1)
	}

	slog.Info("abgen finished successfully.")
}

func buildVersion(version, commit, date, builtBy, treeState string) goversion.Info {
	return goversion.GetVersionInfo(
		goversion.WithAppDetails(types.Application, types.Description, types.WebSite),
		func(i *goversion.Info) {
			i.ASCIIName = types.UI
			if commit != "" {
				i.GitCommit = commit
			}
			if version != "" {
				i.GitVersion = version
			}
			if treeState != "" {
				i.GitTreeState = treeState
			}
			if date != "" {
				i.BuildDate = date
			}
			if builtBy != "" {
				i.BuiltBy = builtBy
			}
		},
	)
}
