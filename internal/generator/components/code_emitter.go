package components

import (
	"bytes"
	"fmt"
	"path"
	"sort"

	"github.com/origadmin/abgen/internal/config"
	"github.com/origadmin/abgen/internal/model"
)

var _ model.CodeEmitter = (*CodeEmitter)(nil)

// CodeEmitter implements the CodeEmitter interface.
type CodeEmitter struct {
	config        *config.Config
	importManager model.ImportManager
	aliasManager  model.AliasManager
}

// NewCodeEmitter creates a new code emitter.
func NewCodeEmitter(
	config *config.Config,
	importManager model.ImportManager,
	aliasManager model.AliasManager,
) model.CodeEmitter {
	return &CodeEmitter{
		config:        config,
		importManager: importManager,
		aliasManager:  aliasManager,
	}
}

// EmitHeader emits the code header.
func (ce *CodeEmitter) EmitHeader(buf *bytes.Buffer) error {
	pkgName := ce.getPackageName()
	buf.WriteString("//go:build !abgen_source\n")
	buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// versions: %s\n", "abgen"))
	buf.WriteString(fmt.Sprintf("// source: %s\n\n", ce.config.GenerationContext.DirectivePath))
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
	return nil
}

// EmitImports emits the import statements.
func (ce *CodeEmitter) EmitImports(buf *bytes.Buffer, imports map[string]string) error {
	if len(imports) == 0 {
		return nil
	}

	paths := make([]string, 0, len(imports))
	for p := range imports {
		paths = append(paths, p)
	}
	sort.Strings(paths)

	buf.WriteString("import(\n")
	for _, importPath := range paths {
		alias := imports[importPath]
		baseAlias := path.Base(importPath)

		if alias != baseAlias {
			buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, importPath))
		} else {
			buf.WriteString(fmt.Sprintf("\t%q\n", importPath))
		}
	}
	buf.WriteString(")\n\n")
	return nil
}

// EmitAliases emits the type aliases.
func (ce *CodeEmitter) EmitAliases(buf *bytes.Buffer, aliases []*model.AliasRenderInfo) error {
	if len(aliases) == 0 {
		return nil
	}

	buf.WriteString("// Local type aliases for external types.\n")
	buf.WriteString("type(\n")
	for _, item := range aliases {
		buf.WriteString(fmt.Sprintf("\t%s = %s\n", item.AliasName, item.OriginalTypeName))
	}
	buf.WriteString(")\n\n")

	return nil
}

// EmitConversions emits the conversion functions.
func (ce *CodeEmitter) EmitConversions(buf *bytes.Buffer, conversions []string) error {
	if len(conversions) == 0 {
		return nil
	}
	for _, conv := range conversions {
		buf.WriteString(conv)
	}
	return nil
}

// EmitHelpers emits the helper functions.
func (ce *CodeEmitter) EmitHelpers(buf *bytes.Buffer, requiredHelpers map[string]struct{}) error {
	if len(requiredHelpers) == 0 {
		return nil
	}

	allHelpers := GetHelperFunctionBodies()
	helperNames := make([]string, 0, len(requiredHelpers))
	for name := range requiredHelpers {
		helperNames = append(helperNames, name)
	}
	sort.Strings(helperNames)

	buf.WriteString("\n// --- Helper Functions ---\n")
	for _, name := range helperNames {
		if body, ok := allHelpers[name]; ok {
			buf.WriteString(body)
		}
	}

	return nil
}

func (ce *CodeEmitter) getPackageName() string {
	if ce.config.GenerationContext.PackageName != "" {
		return ce.config.GenerationContext.PackageName
	}
	return "generated"
}
