package components

import (
	"bytes"
	"fmt"
	"sort"

	"github.com/origadmin/abgen/internal/config"
	"github.com/origadmin/abgen/internal/model"
)

// ConcreteCodeEmitter 实现 CodeEmitter 接口
type ConcreteCodeEmitter struct {
	config              *config.Config
	importManager       model.ImportManager
	aliasManager        model.AliasManager
	nameGenerator       model.NameGenerator
	conversionEngine    model.ConversionEngine
	typeInfos           map[string]*model.TypeInfo
}

// NewCodeEmitter 创建新的代码发射器
func NewCodeEmitter(
	config *config.Config,
	importManager model.ImportManager,
	aliasManager model.AliasManager,
	nameGenerator model.NameGenerator,
	conversionEngine model.ConversionEngine,
	typeInfos map[string]*model.TypeInfo,
) model.CodeEmitter {
	return &ConcreteCodeEmitter{
		config:           config,
		importManager:    importManager,
		aliasManager:     aliasManager,
		nameGenerator:    nameGenerator,
		conversionEngine: conversionEngine,
		typeInfos:        typeInfos,
	}
}

// EmitHeader 发射代码头信息
func (ce *ConcreteCodeEmitter) EmitHeader(buf *bytes.Buffer) error {
	pkgName := ce.getPackageName()
	buf.WriteString("//go:build !abgen_source\n")
	buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// versions: %s\n", "abgen"))
	buf.WriteString(fmt.Sprintf("// source: %s\n\n", ce.config.GenerationContext.DirectivePath))
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
	return nil
}

// EmitImports 发射导入语句
func (ce *ConcreteCodeEmitter) EmitImports(buf *bytes.Buffer, imports []string) error {
	if len(imports) == 0 {
		return nil
	}
	
	buf.WriteString("import(\n")
	sort.Strings(imports)
	for _, importPath := range imports {
		alias := ce.importManager.GetAlias(importPath)
		buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, importPath))
	}
	buf.WriteString(")\n\n")
	return nil
}

// EmitAliases 发射类型别名
func (ce *ConcreteCodeEmitter) EmitAliases(buf *bytes.Buffer) error {
	aliasMap := ce.aliasManager.GetAliasMap()
	requiredAliases := ce.aliasManager.GetRequiredAliases()

	type aliasPair struct {
		aliasName, fqn string
	}
	aliasesToWrite := make([]aliasPair, 0)
	for fqn, alias := range aliasMap {
		// 只生成在 requiredAliases 中存在的 fqn 的别名声明
		if _, ok := requiredAliases[fqn]; !ok {
			continue
		}
		// 跳过在配置中已定义的别名（ExistingAliases）
		if _, exists := ce.config.ExistingAliases[alias]; exists {
			continue
		}
		aliasesToWrite = append(aliasesToWrite, aliasPair{alias, fqn})
	}

	// 过滤掉实际上未被解析的类型（例如，由于错误）的别名
	validAliases := make([]aliasPair, 0)
	for _, alias := range aliasesToWrite {
		if ce.typeInfos[alias.fqn] != nil {
			validAliases = append(validAliases, alias)
		}
	}

	if len(validAliases) == 0 {
		return nil
	}

	sort.Slice(validAliases, func(i, j int) bool { return validAliases[i].aliasName < validAliases[j].aliasName })

	buf.WriteString("// Local type aliases for external types.\n")
	buf.WriteString("type(\n")

	for _, item := range validAliases {
		typeInfo := ce.typeInfos[item.fqn]
		// 使用 nameGenerator.GetTypeString 获取原始类型名称
		originalTypeName := ce.nameGenerator.GetTypeString(typeInfo)
		buf.WriteString(fmt.Sprintf("\t%s = %s\n", item.aliasName, originalTypeName))
	}
	buf.WriteString(")\n\n")

	return nil
}

// EmitConversions 发射转换函数
func (ce *ConcreteCodeEmitter) EmitConversions(buf *bytes.Buffer) error {
	// 1. 首先生成配置规则中的转换函数
	rules := ce.config.ConversionRules
	sort.Slice(rules, func(i, j int) bool { return rules[i].SourceType < rules[j].SourceType })

	for _, rule := range rules {
		sourceInfo := ce.typeInfos[rule.SourceType]
		targetInfo := ce.typeInfos[rule.TargetType]
		if sourceInfo == nil || targetInfo == nil {
			continue
		}
		ce.generateConversionFunction(sourceInfo, targetInfo, rule)
	}

	// 2. 然后生成动态发现的转换函数（如切片转换函数）
	ce.generateDynamicConversionFunctions()

	// 将转换引擎生成的代码写入缓冲区
	if concreteEngine, ok := ce.conversionEngine.(*ConcreteConversionEngine); ok {
		buf.WriteString(concreteEngine.GetGeneratedCode())
	}

	return nil
}

// EmitHelpers 发射辅助函数
func (ce *ConcreteCodeEmitter) EmitHelpers(buf *bytes.Buffer) error {
	requiredFunctions := make(map[string]bool)
	if concreteEngine, ok := ce.conversionEngine.(*ConcreteConversionEngine); ok {
		for funcName := range concreteEngine.GetRequiredFunctions() {
			requiredFunctions[funcName] = true
		}
	}

	if len(requiredFunctions) == 0 {
		return nil
	}

	helpers := make([]string, 0, len(requiredFunctions))
	for name := range requiredFunctions {
		helpers = append(helpers, name)
	}
	sort.Strings(helpers)

	buf.WriteString("\n// --- Helper Functions ---\n")
	for _, name := range helpers {
		if body, ok := getConversionFunctionBodies()[name]; ok {
			buf.WriteString(body)
		}
	}

	return nil
}

// generateConversionFunction 生成转换函数
func (ce *ConcreteCodeEmitter) generateConversionFunction(
	sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule,
) {
	ce.doGenerateConversionFunction(sourceInfo, targetInfo, rule, false)
	if rule.Direction == config.DirectionBoth {
		reverseRule := &config.ConversionRule{
			SourceType: targetInfo.FQN(),
			TargetType: sourceInfo.FQN(),
			Direction:  config.DirectionOneway,
			FieldRules: config.FieldRuleSet{Ignore: make(map[string]struct{}), Remap: make(map[string]string)},
		}
		for from, to := range rule.FieldRules.Remap {
			reverseRule.FieldRules.Remap[to] = from
		}
		ce.doGenerateConversionFunction(targetInfo, sourceInfo, reverseRule, true)
	}
}

// doGenerateConversionFunction 执行转换函数生成
func (ce *ConcreteCodeEmitter) doGenerateConversionFunction(
	sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule, isReverse bool,
) {
	ce.conversionEngine.GenerateConversionFunction(sourceInfo, targetInfo, rule)
}

// generateDynamicConversionFunctions 生成动态发现的转换函数
func (ce *ConcreteCodeEmitter) generateDynamicConversionFunctions() {
	// 收集所有需要切片转换的类型对
	sliceConversions := make(map[string]struct {
		sourceInfo *model.TypeInfo
		targetInfo *model.TypeInfo
	})

	// 扫描所有结构体的字段，找到需要切片转换的地方
	for _, rule := range ce.config.ConversionRules {
		sourceInfo := ce.typeInfos[rule.SourceType]
		targetInfo := ce.typeInfos[rule.TargetType]
		if sourceInfo == nil || targetInfo == nil {
			continue
		}

		// 检查字段中的切片类型
		for _, sourceField := range sourceInfo.Fields {
			var targetField *model.FieldInfo
			// 找到对应的目标字段
			for _, tf := range targetInfo.Fields {
				if tf.Name == sourceField.Name {
					targetField = tf
					break
				}
			}

			if targetField != nil &&
				ce.conversionEngine.(*ConcreteConversionEngine).typeConverter.IsSlice(sourceField.Type) &&
				ce.conversionEngine.(*ConcreteConversionEngine).typeConverter.IsSlice(targetField.Type) {

				sourceElem := ce.conversionEngine.(*ConcreteConversionEngine).typeConverter.GetElementType(sourceField.Type)
				targetElem := ce.conversionEngine.(*ConcreteConversionEngine).typeConverter.GetElementType(targetField.Type)

				if sourceElem != nil && targetElem != nil && sourceElem.UniqueKey() != targetElem.UniqueKey() {
					key := sourceField.Type.UniqueKey() + "->" + targetField.Type.UniqueKey()
					sliceConversions[key] = struct {
						sourceInfo *model.TypeInfo
						targetInfo *model.TypeInfo
					}{
						sourceInfo: sourceField.Type,
						targetInfo: targetField.Type,
					}
				}
			}
		}
	}

	// 生成切片转换函数
	for _, conversion := range sliceConversions {
		ce.conversionEngine.GenerateSliceConversion(conversion.sourceInfo, conversion.targetInfo)
	}
}

// getPackageName 获取包名
func (ce *ConcreteCodeEmitter) getPackageName() string {
	if ce.config.GenerationContext.PackageName != "" {
		return ce.config.GenerationContext.PackageName
	}
	return "generated"
}

// getConversionFunctionBodies 返回转换函数体映射
func getConversionFunctionBodies() map[string]string {
	return map[string]string{
		"ConvertStringToTime": `
func ConvertStringToTime(s string) time.Time {
	t, _ := time.Parse(time.RFC3339, s)
	return t
}
`,
		"ConvertStringToUUID": `
func ConvertStringToUUID(s string) uuid.UUID {
	u, _ := uuid.Parse(s)
	return u
}
`,
		"ConvertTimeToString": `
func ConvertTimeToString(t time.Time) string {
	return t.Format(time.RFC3339)
}
`,
		"ConvertUUIDToString": `
func ConvertUUIDToString(u uuid.UUID) string {
	return u.String()
}
`,
		"ConvertTimeToTimestamp": `
func ConvertTimeToTimestamp(t time.Time) *timestamppb.Timestamp {
	if t.IsZero() {
		return nil
	}
	return timestamppb.New(t)
}
`,
		"ConvertTimestampToTime": `
func ConvertTimestampToTime(ts *timestamppb.Timestamp) time.Time {
	if ts == nil {
		return time.Time{}
	}
	return ts.AsTime()
}
`,
	}
}