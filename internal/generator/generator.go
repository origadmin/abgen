// Package generator is responsible for generating the Go source code based on the
// analysis results from the AST walker.
package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/origadmin/abgen/internal/ast"
	"github.com/origadmin/abgen/internal/types"
)

// ImportManager handles import path collection and alias generation.
type ImportManager struct {
	imports map[string]string // Maps import path to alias
}

// NewImportManager creates a new ImportManager.
func NewImportManager() *ImportManager {
	return &ImportManager{
		imports: make(map[string]string),
	}
}

// Add adds an import path and returns the alias to be used in the generated code.
func (im *ImportManager) Add(importPath string) string {
	if alias, exists := im.imports[importPath]; exists {
		return alias
	}
	// Generate a unique alias to avoid conflicts
	alias := path.Base(importPath)
	originalAlias := alias
	counter := 1
	for {
		isConflict := false
		for _, existingAlias := range im.imports {
			if existingAlias == alias {
				isConflict = true
				alias = originalAlias + strconv.Itoa(counter)
				counter++
				break
			}
		}
		if !isConflict {
			break
		}
	}
	im.imports[importPath] = alias // Map path to its unique alias
	return alias
}

// Generator holds the state required for code generation.
type Generator struct {
	walker  *ast.PackageWalker
	buf     bytes.Buffer
	imports *ImportManager
}

// NewGenerator creates a new Generator instance.
func NewGenerator(walker *ast.PackageWalker) *Generator {
	return &Generator{
		walker: walker,
	}
}

// Generate produces the Go source code for the conversions.
func (g *Generator) Generate() ([]byte, error) {
	g.imports = NewImportManager()

	// Use the package name from the walker's current package context.
	// This ensures the generated file has the correct package declaration.
	pkgName := g.walker.GetCurrentPackage().Name
	g.buf.WriteString("package " + pkgName + "\n\n")

	// --- Generate Header ---
	g.buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	g.buf.WriteString("// versions:\n")
	g.buf.WriteString("// 	abgen v0.0.1\n\n") // Placeholder version

	// --- Collect Imports ---
	// Iterate through all configs to collect all necessary imports.
	for _, cfg := range g.walker.GetRules() { // Use getter
		// Imports for Source Type
		if cfg.Source != nil && cfg.Source.Type != "" && cfg.Source.LocalAlias == "" {
			sourceTypeInfo, err := g.walker.Resolve(cfg.Source.Type)
			if err == nil && sourceTypeInfo.ImportPath != "" && sourceTypeInfo.ImportPath != "builtin" && sourceTypeInfo.ImportPath != g.walker.GetCurrentPackage().PkgPath {
				g.imports.Add(sourceTypeInfo.ImportPath)
			}
		}
		// Imports for Target Type
		if cfg.Target != nil && cfg.Target.Type != "" && cfg.Target.LocalAlias == "" {
			targetTypeInfo, err := g.walker.Resolve(cfg.Target.Type)
			if err == nil && targetTypeInfo.ImportPath != "" && targetTypeInfo.ImportPath != "builtin" && targetTypeInfo.ImportPath != g.walker.GetCurrentPackage().PkgPath {
				g.imports.Add(targetTypeInfo.ImportPath)
			}
		}
	}

	// --- Generate Import Block ---
	if len(g.imports.imports) > 0 {
		// Sort imports for consistent output
		paths := make([]string, 0, len(g.imports.imports))
		for p := range g.imports.imports {
			paths = append(paths, p)
		}
		sort.Strings(paths)

		g.buf.WriteString("import (\n")
		for _, path := range paths {
			alias := g.imports.imports[path]
			g.buf.WriteString("\t" + alias + " " + strconv.Quote(path) + "\n")
		}
		g.buf.WriteString(")\n\n")
	}

	// --- Generate Conversion Functions ---
	g.generateConversionFunctions()

	return format.Source(g.buf.Bytes())
}

func (g *Generator) findField(fields []types.StructField, name string) (types.StructField, bool) {
	for _, field := range fields {
		if strings.EqualFold(field.Name, name) {
			return field, true
		}
	}
	return types.StructField{}, false
}

// generateSingleConversionFunc generates a single struct-to-struct conversion function.
func (g *Generator) generateSingleConversionFunc(cfg *types.ConversionConfig, fromType, toType types.TypeInfo) {
	// --- Determine final Source and Target Type Strings for generated code ---
	// Follows 01_directives.md naming rules (1.2.1 Naming Rules: Source Type Name, Target Type Name)

	// Source Type Name
	sourceTypeName := fromType.Name
	if fromType.LocalAlias != "" {
		sourceTypeName = fromType.LocalAlias
	} else if cfg.SourcePrefix != "" || cfg.SourceSuffix != "" {
		sourceTypeName = cfg.SourcePrefix + fromType.Name + cfg.SourceSuffix
	} else if fromType.Name == toType.Name { // Default suffix rule
		sourceTypeName += "Source"
	}
	finalFromTypeStr := sourceTypeName
	if fromType.ImportPath != "" && fromType.ImportPath != "builtin" && fromType.ImportPath != g.walker.GetCurrentPackage().PkgPath {
		finalFromTypeStr = g.imports.Add(fromType.ImportPath) + "." + sourceTypeName
	}

	// Target Type Name
	targetTypeName := toType.Name
	if toType.LocalAlias != "" {
		targetTypeName = toType.LocalAlias
	} else if cfg.TargetPrefix != "" || cfg.TargetSuffix != "" {
		targetTypeName = cfg.TargetPrefix + toType.Name + cfg.TargetSuffix
	} else if fromType.Name == toType.Name { // Default suffix rule
		targetTypeName += "Target"
	}
	finalToTypeStr := targetTypeName
	if toType.ImportPath != "" && toType.ImportPath != "builtin" && toType.ImportPath != g.walker.GetCurrentPackage().PkgPath {
		finalToTypeStr = g.imports.Add(toType.ImportPath) + "." + targetTypeName
	}

	// --- Function Name Generation ---
	// Follows 01_directives.md naming rules (1.2.1 Naming Rules: Struct Conversion Function)
	funcName := "Convert" + sourceTypeName + "To" + targetTypeName

	g.buf.WriteString(fmt.Sprintf("// %s converts a *%s to a *%s.\n", funcName, finalFromTypeStr, finalToTypeStr))
	g.buf.WriteString(fmt.Sprintf("func %s(from *%s) *%s {\n", funcName, finalFromTypeStr, finalToTypeStr))
	g.buf.WriteString("\tif from == nil {\n")
	g.buf.WriteString("\t\treturn nil\n")
	g.buf.WriteString("\t}\n")
	g.buf.WriteString(fmt.Sprintf("\tto := &%s{}\n\n", finalToTypeStr))

	for _, sourceField := range fromType.Fields {
		ruleKeyPrefix := fromType.ImportPath + "." + fromType.Name
		if fromType.LocalAlias != "" {
			ruleKeyPrefix = fromType.LocalAlias
		}
		sourceFieldFQN := ruleKeyPrefix + "#" + sourceField.Name

		// 1. Check for ignores (Priority 3 in 01_directives.md)
		if _, ignored := cfg.IgnoreFields[sourceFieldFQN]; ignored {
			g.buf.WriteString(fmt.Sprintf("\t// Ignored field: %s\n", sourceField.Name))
			continue
		}

		// 2. Check for remaps (Priority 2 in 01_directives.md)
		if targetPath, ok := cfg.RemapFields[sourceFieldFQN]; ok {
			g.buf.WriteString(fmt.Sprintf("\t// Remap: %s -> %s\n", sourceField.Name, targetPath))
			g.handleFieldAssignment(sourceField, targetPath, &toType)
			continue
		}

		// 3. Default: case-insensitive name matching
		if targetField, ok := g.findField(toType.Fields, sourceField.Name); ok {
			g.handleFieldAssignment(sourceField, targetField.Name, &toType)
		}
	}

	g.buf.WriteString("\n\treturn to\n")
	g.buf.WriteString("}\n")
}

func (g *Generator) handleFieldAssignment(sourceField types.StructField, targetPath string, toType *types.TypeInfo) {
	targetPathParts := strings.Split(targetPath, ".")

	currentPath := "to"
	currentTypeInfo := toType

	// Handle nil checks for nested structs
	for _, part := range targetPathParts[:len(targetPathParts)-1] {
		field, ok := g.findField(currentTypeInfo.Fields, part)
		if !ok {
			g.buf.WriteString(fmt.Sprintf("\t// WARNING: Intermediate field '%s' in remap path not found in %s.\n", part, currentTypeInfo.Name))
			return // Cannot proceed
		}

		fieldTypeInfo, err := g.walker.Resolve(field.Type)
		if err != nil {
			g.buf.WriteString(fmt.Sprintf("\t// WARNING: Could not resolve type for intermediate field '%s'.\n", field.Name))
			return
		}

		if fieldTypeInfo.IsPointer {
			g.buf.WriteString(fmt.Sprintf("\tif %s.%s == nil {\n", currentPath, field.Name))
			// Get type name without pointer for initialization
			// Example: *types.Edges -> types.Edges
			initType := strings.TrimPrefix(fieldTypeInfo.Name, "*")
			// Need to ensure the package alias is used if it's an external type
			if fieldTypeInfo.ImportPath != "" && fieldTypeInfo.ImportPath != "builtin" && fieldTypeInfo.ImportPath != g.walker.GetCurrentPackage().PkgPath {
				initType = g.imports.Add(fieldTypeInfo.ImportPath) + "." + initType
			}
			g.buf.WriteString(fmt.Sprintf("\t\t%s.%s = &%s{}\n", currentPath, field.Name, initType))
			g.buf.WriteString("\t}\n")
		}
		currentPath += "." + field.Name

		// Resolve the type of the intermediate field for the next iteration
		currentTypeInfo = fieldTypeInfo
	}

	finalTargetPath := "to." + targetPath // This should be 'currentPath' if intermediate path is built
	finalTargetFieldName := targetPathParts[len(targetPathParts)-1]

	// Find the final target field to get its type.
	targetField, ok := g.findField(currentTypeInfo.Fields, finalTargetFieldName)
	if !ok {
		g.buf.WriteString(fmt.Sprintf("\t// WARNING: Final target field '%s' for remap path not found in %s.\n", finalTargetFieldName, currentTypeInfo.Name))
		return
	}

	sourceTypeClean := strings.TrimPrefix(sourceField.Type, "builtin.")
	targetTypeClean := strings.TrimPrefix(targetField.Type, "builtin.")

	if sourceTypeClean == targetTypeClean {
		g.buf.WriteString(fmt.Sprintf("\t%s = from.%s\n", finalTargetPath, sourceField.Name))
	} else {
		// This is where function promotion will happen. For now, call a placeholder.
		conversionFuncName := "Convert" + strings.Title(sourceField.Name) + "To" + strings.Title(targetField.Name)
		g.buf.WriteString(fmt.Sprintf("\t%s = %s(from.%s)\n", finalTargetPath, conversionFuncName, sourceField.Name))
		// TODO: Register this conversion function to be generated.
	}
}

func (g *Generator) generateConversionFunctions() {
	// Collect all configs first and then sort.
	var allConfigs []*types.ConversionConfig
	for _, cfg := range g.walker.GetRules() { // Use getter
		allConfigs = append(allConfigs, cfg)
	}

	// Sort by source type and then target type for stable output.
	sort.Slice(allConfigs, func(i, j int) bool {
		if allConfigs[i].Source.Type != allConfigs[j].Source.Type {
			return allConfigs[i].Source.Type < allConfigs[j].Source.Type
		}
		return allConfigs[i].Target.Type < allConfigs[j].Target.Type
	})

	for _, cfg := range allConfigs {
		sourceTypeInfo, err := g.walker.Resolve(cfg.Source.Type)
		if err != nil {
			g.buf.WriteString(fmt.Sprintf("// ERROR: could not resolve source type %q: %v\n", cfg.Source.Type, err))
			continue
		}
		targetTypeInfo, err := g.walker.Resolve(cfg.Target.Type)
		if err != nil {
			g.buf.WriteString(fmt.Sprintf("// ERROR: could not resolve target type %q: %v\n", cfg.Target.Type, err))
			continue
		}

		// Generate forward conversion
		g.generateSingleConversionFunc(cfg, *sourceTypeInfo, *targetTypeInfo) // Pass cfg directly // Dereference
		g.buf.WriteString("\n")                                               // Add a newline between functions

		// Generate reverse conversion if direction is "both"
		if cfg.Direction == "both" {
			// For reverse, we need to create a reversed config view
			reverseCfg := cfg.Clone() // Clone current config
			// Swap source and target endpoints
			reverseCfg.Source = cfg.Target.Clone()
			reverseCfg.Target = cfg.Source.Clone()
			// Swap prefixes/suffixes for the reverse conversion as well
			reverseCfg.SourcePrefix = cfg.TargetPrefix
			reverseCfg.SourceSuffix = cfg.TargetSuffix
			reverseCfg.TargetPrefix = cfg.SourcePrefix
			reverseCfg.TargetSuffix = cfg.SourceSuffix
			reverseCfg.Direction = "to" // The reverse is always a simple "to"

			g.generateSingleConversionFunc(
				reverseCfg,      // Pass the reversed config
				*targetTypeInfo, // Pass target as new source // Dereference
				*sourceTypeInfo, // Pass source as new target // Dereference
			)
			g.buf.WriteString("\n") // Add a newline between functions
		}
	}
}
