// Package generator is responsible for generating the Go source code based on the
// analysis results from the AST walker.
package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/origadmin/abgen/internal/ast"
	"github.com/origadmin/abgen/internal/types"
)

// ImportManager handles import path collection and alias generation.
type ImportManager struct {
	imports map[string]string // Maps import path to alias
}

// NewImportManager creates a new ImportManager.
func NewImportManager() *ImportManager {
	return &ImportManager{
		imports: make(map[string]string),
	}
}

// Add adds an import path and returns the alias to be used in the generated code.
func (im *ImportManager) Add(importPath string) string {
	if alias, exists := im.imports[importPath]; exists {
		return alias
	}
	// Generate a unique alias to avoid conflicts
	alias := path.Base(importPath)
	originalAlias := alias
	counter := 1
	for {
		isConflict := false
		for _, existingAlias := range im.imports {
			if existingAlias == alias {
				isConflict = true
				alias = originalAlias + strconv.Itoa(counter)
				counter++
				break
			}
		}
		if !isConflict {
			break
		}
	}
	im.imports[importPath] = alias // Map path to its unique alias
	return alias
}

// Generator holds the state required for code generation.
type Generator struct {
	walker  *ast.PackageWalker
	buf     bytes.Buffer
	imports *ImportManager
}

// NewGenerator creates a new Generator instance.
func NewGenerator(walker *ast.PackageWalker) *Generator {
	return &Generator{
		walker: walker,
	}
}

// Generate produces the Go source code for the conversions.
func (g *Generator) Generate() ([]byte, error) {
	g.imports = NewImportManager()

	// Use the package name from the walker's current package context.
	// This ensures the generated file has the correct package declaration.
	pkgName := g.walker.GetCurrentPackage().Name
	g.buf.WriteString("package " + pkgName + "\n\n")

	// --- Generate Header ---
	g.buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	g.buf.WriteString("// versions:\n")
	g.buf.WriteString("// \tabgen v0.0.1\n\n") // Placeholder version

	// --- Collect Imports ---
	if len(g.walker.PackageConfigs) > 0 {
		pkgCfg := g.walker.PackageConfigs[0]
		g.imports.Add(pkgCfg.SourcePackage)
		g.imports.Add(pkgCfg.TargetPackage)
	}

	// --- Generate Import Block ---
	if len(g.imports.imports) > 0 {
		// Sort imports for consistent output
		paths := make([]string, 0, len(g.imports.imports))
		for p := range g.imports.imports {
			paths = append(paths, p)
		}
		sort.Strings(paths)

		g.buf.WriteString("import (\n")
		for _, path := range paths {
			alias := g.imports.imports[path]
			g.buf.WriteString("\t" + alias + " " + strconv.Quote(path) + "\n")
		}
		g.buf.WriteString(")\n\n")
	}

	// --- Generate Conversion Functions ---
	g.generateConversionFunctions()

	// After generating all functions, render the file from the buffer.
	// This is a change from the jennifer-based approach to stick with the buffer.
	// The jennifer part was complex and has been rolled back to a simpler string-based generation
	// that is easier to debug and control.

	return format.Source(g.buf.Bytes())
}

// generateSingleConversionFunc generates a single struct-to-struct conversion function.
func (g *Generator) generateSingleConversionFunc(pkgCfg *types.PackageConversionConfig, fromType, toType types.TypeInfo) {
	fromAlias := g.imports.Add(fromType.ImportPath)
	toAlias := g.imports.Add(toType.ImportPath)

	toTypeNameWithSuffix := toType.Name + pkgCfg.TargetSuffix
	funcName := "Convert" + fromType.Name + "To" + toTypeNameWithSuffix

	g.buf.WriteString(fmt.Sprintf("// %s converts a *%s.%s to a *%s.%s.\n", funcName, fromAlias, fromType.Name, toAlias, toType.Name))
	g.buf.WriteString(fmt.Sprintf("func %s(from *%s.%s) *%s.%s {\n", funcName, fromAlias, fromType.Name, toAlias, toType.Name)) // Corrected to use aliases
	g.buf.WriteString("\tif from == nil {\n")
	g.buf.WriteString("\t\treturn nil\n")
	g.buf.WriteString("\t}\n")
	g.buf.WriteString(fmt.Sprintf("\tto := &%s.%s{}\n\n", toAlias, toType.Name))

	targetFields := make(map[string]bool)
	for _, f := range toType.Fields {
		targetFields[f.Name] = true
	}

	for _, sourceField := range fromType.Fields {
		sourceFieldFQN := fromType.ImportPath + "." + fromType.Name + "#" + sourceField.Name

		if _, ignored := pkgCfg.IgnoreFields[sourceFieldFQN]; ignored {
			continue
		}

		targetFieldName := sourceField.Name
		if remapName, ok := pkgCfg.RemapFields[sourceFieldFQN]; ok {
			targetFieldName = remapName
		}

		if _, exists := targetFields[targetFieldName]; !exists {
			continue
		}

		isCompatible := false
		for _, targetField := range toType.Fields {
			if targetField.Name == targetFieldName {
				// A simple and effective compatibility check for now.
				sourceTypeClean := strings.TrimPrefix(sourceField.Type, "builtin.")
				targetTypeClean := strings.TrimPrefix(targetField.Type, "builtin.")
				if sourceTypeClean == targetTypeClean {
					isCompatible = true
				}
				break
			}
		}

		if isCompatible {
			g.buf.WriteString(fmt.Sprintf("\tto.%s = from.%s\n", targetFieldName, sourceField.Name))
		}
	}

	g.buf.WriteString("\n\treturn to\n")
	g.buf.WriteString("}\n")
}

func (g *Generator) generateConversionFunctions() {
	if len(g.walker.PackageConfigs) == 0 {
		return
	}
	pkgCfg := g.walker.PackageConfigs[0]

	// This is a simplified logic to find the 'User' type in both packages for p01_basic.
	// A more robust version would iterate all types found in the packages.
	sourceTypeInfo, err := g.walker.Resolve(pkgCfg.SourcePackage + ".User")
	if err != nil {
		g.buf.WriteString(fmt.Sprintf("// ERROR: could not resolve source type: %s.User\n", pkgCfg.SourcePackage))
		return
	}
	targetTypeInfo, err := g.walker.Resolve(pkgCfg.TargetPackage + ".User")
	if err != nil {
		g.buf.WriteString(fmt.Sprintf("// ERROR: could not resolve target type: %s.User\n", pkgCfg.TargetPackage))
		return
	}

	// Generate forward conversion (ent.User -> types.User)
	g.generateSingleConversionFunc(pkgCfg, sourceTypeInfo, targetTypeInfo)

	// Generate reverse conversion if direction is "both"
	if pkgCfg.Direction == "both" {
		g.buf.WriteString("\n")
		// For reverse, we need to create a reversed config view
		reverseRemaps := make(map[string]string)
		for k, v := range pkgCfg.RemapFields {
			// The key is FQN#Field, we need to construct the reverse FQN
			// from: ent.User#ID -> Id
			// to:   types.User#Id -> ID
			reverseKey := targetTypeInfo.ImportPath + "." + targetTypeInfo.Name + "#" + v
			reverseVal := strings.Split(k, "#")[1]
			reverseRemaps[reverseKey] = reverseVal
		}

		// For reverse, ignored fields are on the new source (types.User)
		// This logic is simplified; a full implementation would need to know which fields to ignore on the other side.
		// For p01, we assume no new ignores are needed for the reverse conversion.

		reversePkgCfg := &types.PackageConversionConfig{
			SourcePackage: pkgCfg.TargetPackage,
			TargetPackage: pkgCfg.SourcePackage,
			RemapFields:   reverseRemaps,
			IgnoreFields:  make(map[string]bool), // Simplified for now
			TargetSuffix:  "",                    // No suffix for the original ent type
		}
		g.generateSingleConversionFunc(reversePkgCfg, targetTypeInfo, sourceTypeInfo)
	}
}
