// Package generator is responsible for generating the Go source code based on the
// analysis results from the analyzer and configuration from the config package.
package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"go/types"
	"log/slog"
	"sort"
	"strings"

	"github.com/origadmin/abgen/internal/analyzer"
	"github.com/origadmin/abgen/internal/config"
	"github.com/origadmin/abgen/internal/model"
)

// Generator holds the state for code generation.
type Generator struct {
	walker    *analyzer.PackageWalker
	ruleSet   *config.RuleSet
	buf       bytes.Buffer
	importMgr *ImportManager
	converter *TypeConverter
	namer     *Namer
	tasks     []*model.ConversionTask
	processed map[string]bool
	aliasMap  map[string]string // Maps FQN to alias
}

// NewGenerator creates a new Generator instance.
func NewGenerator(walker *analyzer.PackageWalker, ruleSet *config.RuleSet) *Generator {
	return &Generator{
		walker:    walker,
		ruleSet:   ruleSet,
		importMgr: NewImportManager(),
		converter: NewTypeConverter(),
		namer:     NewNamer(ruleSet),
		tasks:     make([]*model.ConversionTask, 0),
		processed: make(map[string]bool),
		aliasMap:  make(map[string]string),
	}
}

// Generate produces the Go source code for the conversions.
func (g *Generator) Generate() ([]byte, error) {
	// 1. Discover all conversion tasks (explicit and automatic)
	if err := g.DiscoverTasks(); err != nil {
		return nil, fmt.Errorf("failed to discover conversion tasks: %w", err)
	}

	// 2. Populate aliases for all referenced types (Pass 1)
	g.populateAliases()

	// 3. Generate the actual code using the populated tasks and aliases (Pass 2)
	g.buf.Reset()
	g.writePackageHeader()
	g.writeImports()
	g.writeAliases()
	g.writeConversionFunctions()

	// 4. Format and return
	return format.Source(g.buf.Bytes())
}

// CustomStubs generates custom conversion stubs for complex conversions.
func (g *Generator) CustomStubs() []byte {
	var stubBuf bytes.Buffer
	
	stubBuf.WriteString("package ")
	stubBuf.WriteString(g.getPackageName())
	stubBuf.WriteString("\n\n")
	stubBuf.WriteString("// Code generated by abgen for custom conversion stubs. DO NOT EDIT.\n\n")

	// Generate stubs for complex conversions that need manual implementation
	for _, task := range g.tasks {
		if !task.IsAlias && g.needsCustomStub(task) {
			g.writeCustomStub(&stubBuf, task)
		}
	}

	// Format the stub code
	formatted, err := format.Source(stubBuf.Bytes())
	if err != nil {
		slog.Warn("Failed to format custom stubs", "error", err)
		return stubBuf.Bytes()
	}
	return formatted
}

func (g *Generator) writePackageHeader() {
	pkgName := g.getPackageName()
	g.buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
	g.buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n\n")
}

func (g *Generator) writeImports() {
	// The import manager is populated during alias and task discovery.
	imports := g.importMgr.GetAllImports()
	if len(imports) == 0 {
		return
	}
	g.buf.WriteString("import (\n")
	// Sort imports for consistent output
	sortedImports := make([]string, 0, len(imports))
	for _, importPath := range imports {
		sortedImports = append(sortedImports, importPath)
	}
	sort.Strings(sortedImports)

	for _, importPath := range sortedImports {
		alias := g.importMgr.GetAlias(importPath)
		g.buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, importPath))
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) writeAliases() {
	if len(g.aliasMap) == 0 {
		return
	}
	g.buf.WriteString("// Local type aliases for external types.\n")
	g.buf.WriteString("type (\n")
	// To ensure consistent output, sort the aliases by alias name
	type aliasPair struct {
		aliasName string // The local alias name, e.g., "DepartmentPB"
		typeModel *model.Type // The model.Type representing the actual type
	}
	aliases := make([]aliasPair, 0, len(g.aliasMap))
	for fqn, alias := range g.aliasMap {
		typeInfo, err := g.walker.FindTypeByFQN(fqn) // Get the analyzer.TypeInfo for the FQN
		if err != nil {
			// This case should ideally not happen if populateAliases is robust
			slog.Error("Failed to find TypeInfo for FQN during alias writing", "fqn", fqn, "error", err)
			continue
		}
		typeModel := g.converter.ConvertToModel(typeInfo) // Convert to model.Type
		if typeModel == nil {
			slog.Error("Failed to convert TypeInfo to ModelType during alias writing", "fqn", fqn)
			continue
		}
		aliases = append(aliases, aliasPair{
			aliasName: alias,
			typeModel: typeModel,
		})
	}

	sort.Slice(aliases, func(i, j int) bool {
		return aliases[i].aliasName < aliases[j].aliasName
	})

	for _, item := range aliases {
		// The right-hand side of the alias should be the fully qualified original type,
		// using the ImportManager's aliases for its package.
		originalTypeName := g.getTypeString(item.typeModel) // Use the new getTypeString
		g.buf.WriteString(fmt.Sprintf("\t%s = %s\n", item.aliasName, originalTypeName))
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) writeConversionFunctions() {
	// Sort tasks to ensure consistent output
	sort.Slice(g.tasks, func(i, j int) bool {
		return g.tasks[i].SourceType.GetFQN() < g.tasks[j].SourceType.GetFQN()
	})

	for _, task := range g.tasks {
		// Alias tasks were already handled by writeAliases
		if !task.IsAlias {
			g.generateConversionFunction(task)
		}
	}
}

// populateAliases is Pass 1. It iterates through all tasks and ensures
// every external type has a defined alias.
func (g *Generator) populateAliases() {
	// 1. Define the set of "source" packages
	sourcePackages := make(map[string]struct{})
	for k := range g.ruleSet.PackagePairs {
		sourcePackages[k] = struct{}{}
	}

	// 2. Gather all unique types that need aliasing

uniqueTypes := make(map[string]*model.Type)
	for _, task := range g.tasks {
		g.collectTypes(task.SourceType, uniqueTypes)
		g.collectTypes(task.TargetType, uniqueTypes)
	}

	// 3. Create an alias for each unique type
	for _, t := range uniqueTypes {
		_, isSourcePkg := sourcePackages[t.ImportPath]

		// Check if an explicit alias was already defined for this type by a `convert` rule.
		var forcedAliasName string
		for _, task := range g.tasks {
			if task.IsAlias && task.SourceType.GetFQN() == t.GetFQN() {
				forcedAliasName = task.AliasName
				break
			}
		}

		g.addAliasForType(t, isSourcePkg, forcedAliasName)
	}
}

// collectTypes recursively finds all types within a given type (including itself)
// that may need an alias and adds them to the collection.
func (g *Generator) collectTypes(t *model.Type, collection map[string]*model.Type) {
	if t == nil || t.ImportPath == "" || t.ImportPath == "builtin" || g.isCurrentPackage(t.ImportPath) {
		return
	}

	fqn := t.GetFQN()
	if _, exists := collection[fqn]; exists {
		return // Already seen
	}
	collection[fqn] = t

	// Recurse for nested types
	if t.ElementType != nil {
		g.collectTypes(t.ElementType, collection)
	}
	for _, field := range t.Fields {
		g.collectTypes(field.Type, collection)
	}
}


// addAliasForType adds an alias for a single type if it doesn't have one already.
func (g *Generator) addAliasForType(t *model.Type, isSourcePkg bool, forcedAliasName string) {
	if t == nil || t.ImportPath == "" || t.ImportPath == "builtin" || g.isCurrentPackage(t.ImportPath) {
		return
	}

	fqn := t.GetFQN()
	if _, exists := g.aliasMap[fqn]; exists {
		return // Already processed
	}

	g.importMgr.Add(t.ImportPath)

	aliasName := forcedAliasName
	if aliasName == "" {
		if isSourcePkg {
			aliasName = t.Name // Simple name for source side
		} else {
			aliasName = g.namer.GetAliasName(t) // Rule-based name for target side
		}
	}

	finalAlias := aliasName
	i := 1
	for g.isAliasInUse(finalAlias) {
		finalAlias = fmt.Sprintf("%s%d", aliasName, i)
		i++
	}
	g.aliasMap[fqn] = finalAlias
}


func (g *Generator) isAliasInUse(alias string) bool {
	for _, existingAlias := range g.aliasMap {
		if existingAlias == alias {
			return true
		}
	}
	return false
}

func (g *Generator) generateConversionFunction(task *model.ConversionTask) {
	sourceType := task.SourceType
	targetType := task.TargetType

	funcName := g.namer.GetFunctionName(sourceType, targetType)
	sourceParam := g.getTypeString(sourceType)
	targetParam := g.getTypeString(targetType)

	g.buf.WriteString(fmt.Sprintf("// %s converts %s to %s\n", funcName, sourceParam, targetParam))
	// 根据类型确定是否使用指针
	sourceParamType := sourceParam
	targetParamType := targetParam
	
	if sourceType.Kind == model.TypeKindStruct && !sourceType.IsPointer {
		sourceParamType = "*" + sourceParam
	}
	if targetType.Kind == model.TypeKindStruct && !targetType.IsPointer {
		targetParamType = "*" + targetParam
	}
	
	g.buf.WriteString(fmt.Sprintf("func %s(from %s) %s {\n", funcName, sourceParamType, targetParamType))

	if sourceType.IsPointer {
		g.buf.WriteString("\tif from == nil {\n\t\treturn nil\n\t}\n")
	}

	switch {
	case sourceType.Kind == model.TypeKindStruct && targetType.Kind == model.TypeKindStruct:
		g.generateStructToStructConversion(sourceType, targetType)
	case sourceType.Kind == model.TypeKindSlice && targetType.Kind == model.TypeKindSlice:
		g.generateSliceToSliceConversion(sourceType, targetType)
	case sourceType.Kind == model.TypeKindArray && targetType.Kind == model.TypeKindArray:
		g.generateArrayToArrayConversion(sourceType, targetType)
	case sourceType.Kind == model.TypeKindArray && targetType.Kind == model.TypeKindSlice:
		g.generateArrayToSliceConversion(sourceType, targetType)
	case sourceType.Kind == model.TypeKindSlice && targetType.Kind == model.TypeKindArray:
		g.generateSliceToArrayConversion(sourceType, targetType)
	default:
		g.generateBasicConversion(sourceType, targetType)
	}

	g.buf.WriteString("}\n\n")
}

func (g *Generator) generateStructToStructConversion(source, target *model.Type) {
	targetTypeName := g.getTypeString(target)
	if !strings.HasPrefix(targetTypeName, "*") {
		targetTypeName = "*" + targetTypeName
	}
	g.buf.WriteString(fmt.Sprintf("\tto := %s{}\n\n", targetTypeName))

	for _, sourceField := range source.Fields {
		targetFieldName := g.getTargetFieldName(sourceField.Name)
		targetField := g.findField(target, targetFieldName)
		if targetField == nil {
			continue
		}

		if g.shouldIgnoreField(source, sourceField.Name) {
			continue
		}
		g.generateFieldAssignment(sourceField, targetField)
	}

	g.buf.WriteString("\treturn to\n")
}

func (g *Generator) generateSliceToSliceConversion(source, target *model.Type) {
	targetTypeName := g.getTypeString(target)
	g.buf.WriteString(fmt.Sprintf("\tif from == nil {\n\t\treturn nil\n\t}\n"))
	g.buf.WriteString(fmt.Sprintf("\tto := make(%s, len(from))\n", targetTypeName))
	g.buf.WriteString("\tfor i, item := range from {\n")
	elemFuncName := g.getFunctionName(source.ElementType, target.ElementType)
	g.buf.WriteString(fmt.Sprintf("\t\to[i] = %s(item)\n", elemFuncName))
	g.buf.WriteString("\t}\n\treturn to\n")
}

func (g *Generator) generateArrayToArrayConversion(source, target *model.Type) {
	targetTypeName := g.getTypeString(target)
	
	g.buf.WriteString(fmt.Sprintf("\tif len(from) == 0 {\n\t\treturn %s{}\n\t}\n", targetTypeName))
	g.buf.WriteString(fmt.Sprintf("\tto := %s{}\n", targetTypeName))
	g.buf.WriteString("\tfor i := 0; i < len(from) && i < len(to); i++ {\n")
	elemFuncName := g.getFunctionName(source.ElementType, target.ElementType)
	g.buf.WriteString(fmt.Sprintf("\t\tto[i] = %s(from[i])\n", elemFuncName))
	g.buf.WriteString("\t}\n\treturn to\n")
}

func (g *Generator) generateArrayToSliceConversion(source, target *model.Type) {
	targetTypeName := g.getTypeString(target)
	g.buf.WriteString(fmt.Sprintf("\tif len(from) == 0 {\n\t\treturn nil\n\t}\n"))
	g.buf.WriteString(fmt.Sprintf("\tto := make(%s, len(from))\n", targetTypeName))
	g.buf.WriteString("\tfor i, item := range from {\n")
	elemFuncName := g.getFunctionName(source.ElementType, target.ElementType)
	g.buf.WriteString(fmt.Sprintf("\t\to[i] = %s(item)\n", elemFuncName))
	g.buf.WriteString("\t}\n\treturn to\n")
}

func (g *Generator) generateSliceToArrayConversion(source, target *model.Type) {
	targetTypeName := g.getTypeString(target)
	g.buf.WriteString(fmt.Sprintf("\tif from == nil {\n\t\treturn %s{}\n\t}\n", targetTypeName))
	g.buf.WriteString(fmt.Sprintf("\tto := %s{}\n", targetTypeName))
	g.buf.WriteString("\tminLen := len(from)\n")
	g.buf.WriteString("\tif minLen > len(to) {\n\t\tminLen = len(to)\n\t}\n")
	g.buf.WriteString("\tfor i := 0; i < minLen; i++ {\n")
	elemFuncName := g.getFunctionName(source.ElementType, target.ElementType)
	g.buf.WriteString(fmt.Sprintf("\t\tto[i] = %s(from[i])\n", elemFuncName))
	g.buf.WriteString("\t}\n\treturn to\n")
}

func (g *Generator) generateBasicConversion(source, target *model.Type) {
	targetTypeName := g.getTypeString(target)
	
	// 检查是否为相同类型
	if g.isSameType(source, target) {
		g.buf.WriteString(fmt.Sprintf("\treturn %s(from)\n", targetTypeName))
		return
	}
	
	// 检查是否为可识别的基本类型转换
	if g.canDirectConvert(source, target) {
		g.buf.WriteString(fmt.Sprintf("\treturn %s(from)\n", targetTypeName))
		return
	}
	
	// 对于不支持的转换，生成有意义的实现而不是panic
	if source.Kind == model.TypeKindPrimitive && target.Kind == model.TypeKindPrimitive {
		// 基本类型之间尝试类型转换
		g.buf.WriteString(fmt.Sprintf("\treturn %s(from)\n", targetTypeName))
	} else {
		// 生成stub提示用户实现
		g.buf.WriteString(fmt.Sprintf("\t// TODO: Implement conversion from %s to %s\n", source.Name, target.Name))
		g.buf.WriteString("\t// For complex types, please implement this conversion manually\n")
		g.buf.WriteString(fmt.Sprintf("\t// Expected: %s -> %s\n", source.Name, target.Name))
		g.buf.WriteString("\tpanic(\"conversion not implemented: please implement manually\")\n")
	}
}

func (g *Generator) generateFieldAssignment(sourceField, targetField *model.Field) {
	sourceAccess := fmt.Sprintf("from.%s", sourceField.Name)
	targetAccess := fmt.Sprintf("to.%s", targetField.Name)
	sourceType := sourceField.Type
	targetType := targetField.Type

	if g.isSameType(sourceType, targetType) {
		g.buf.WriteString(fmt.Sprintf("\t%s = %s\n", targetAccess, sourceAccess))
		return
	}

	// Handle slice and array conversions for fields
	if (sourceType.Kind == model.TypeKindSlice || sourceType.Kind == model.TypeKindArray) &&
		(targetType.Kind == model.TypeKindSlice || targetType.Kind == model.TypeKindArray) {
		// Ensure a top-level conversion function will be generated for this type pair
		g.AddTask(sourceType, targetType, false, "")
		convFunc := g.getFunctionName(sourceType, targetType)
		g.buf.WriteString(fmt.Sprintf("\t%s = %s(%s)\n", targetAccess, convFunc, sourceAccess))
		return
	}


	convFuncName := g.getFunctionName(sourceType, targetType)
	if convFuncName != "" {
		g.buf.WriteString(fmt.Sprintf("\t%s = %s(%s)\n", targetAccess, convFuncName, sourceAccess))
	} else {
		g.buf.WriteString(fmt.Sprintf("\t// TODO: Convert %s field %s\n", sourceType.Name, sourceField.Name))
		// 添加转换任务
		g.AddTask(sourceType, targetType, false, "")
		convFunc := g.getFunctionName(sourceType, targetType)
		if convFunc != "" {
			g.buf.WriteString(fmt.Sprintf("\t%s = %s(%s)\n", targetAccess, convFunc, sourceAccess))
		}
	}
}

func (g *Generator) getFunctionName(source, target *model.Type) string {
	return g.namer.GetFunctionName(source, target)
}

// getTypeString returns the string representation of a type (e.g., "[]*pkg.MyType").
// It handles slices, pointers, local aliases, and package imports.
func (g *Generator) getTypeString(t *model.Type) string {
	if t == nil {
		return "invalid"
	}

	var builder strings.Builder

	// Handle slices and pointers recursively
	switch t.Kind {
	case model.TypeKindSlice:
		builder.WriteString("[]")
		builder.WriteString(g.getTypeString(t.ElementType)) // Recursively call for element type
	case model.TypeKindPointer:
		builder.WriteString("*")
		builder.WriteString(g.getTypeString(t.ElementType)) // Recursively call for element type
	default:
		// Base type (struct, primitive, named type)
		// Check for a local type alias for this base type (e.g., DepartmentPB)
		if alias, ok := g.aliasMap[t.GetFQN()]; ok {
			builder.WriteString(alias)
		} else if t.ImportPath != "" && !g.isCurrentPackage(t.ImportPath) {
			// External type, use import alias (e.g., source.Department)
			g.importMgr.Add(t.ImportPath) // Ensure the import is registered
			if importAlias := g.importMgr.GetAlias(t.ImportPath); importAlias != "" {
				builder.WriteString(fmt.Sprintf("%s.%s", importAlias, t.Name))
			} else {
				// Fallback if alias somehow not found (shouldn't happen with robust Add)
				builder.WriteString(t.Name)
			}
		} else {
			// Current package type or built-in
			builder.WriteString(t.Name)
		}
	}

	return builder.String()
}


func (g *Generator) getPackageName() string {
	if g.ruleSet != nil && g.ruleSet.Context.PackageName != "" {
		return g.ruleSet.Context.PackageName
	}
	return "generated"
}

func (g *Generator) isCurrentPackage(importPath string) bool {
	if g.ruleSet != nil && g.ruleSet.Context.PackagePath != "" {
		return g.ruleSet.Context.PackagePath == importPath
	}
	return false
}

func (g *Generator) getTargetFieldName(sourceFieldName string) string {
	return sourceFieldName
}

func (g *Generator) shouldIgnoreField(t *model.Type, fieldName string) bool {
	return false
}

func (g *Generator) findField(structType *model.Type, fieldName string) *model.Field {
	for _, field := range structType.Fields {
		if strings.EqualFold(field.Name, fieldName) {
			return field
		}
	}
	return nil
}

func (g *Generator) isSameType(a, b *model.Type) bool {
	return a.GetFQN() == b.GetFQN()
}

func (g *Generator) canDirectConvert(source, target *model.Type) bool {
	return source.Name == target.Name
}

func (g *Generator) AddTask(sourceType, targetType *model.Type, isAlias bool, aliasName string) {
	// Avoid duplicating tasks
	taskKey := fmt.Sprintf("%s->%s", sourceType.GetFQN(), targetType.GetFQN())
	if g.processed[taskKey] {
		return
	}
	task := &model.ConversionTask{
		SourceType: sourceType,
		TargetType: targetType,
		Direction:  model.DirectionTo,
		RuleSet:    g.ruleSet,
		IsAlias:    isAlias,
		AliasName:  aliasName,
	}
	g.tasks = append(g.tasks, task)
	g.processed[taskKey] = true
}

func (g *Generator) DiscoverTasks() error {
	slog.Debug("Discovering conversion tasks...")

	for sourceFQN, targetName := range g.ruleSet.TypePairs {
		slog.Debug("Processing explicit type pair", "sourceFQN", sourceFQN, "targetName", targetName)
		if g.processed[sourceFQN] {
			continue
		}

		sourceTypeInfo, err := g.walker.FindTypeByFQN(sourceFQN)
		if err != nil {
			slog.Error("Failed to find source type for explicit pair", "fqn", sourceFQN, "error", err)
			continue
		}
		sourceModelType := g.converter.ConvertToModel(sourceTypeInfo)
		if sourceModelType == nil {
			slog.Error("Failed to convert source for explicit pair", "fqn", sourceFQN)
			continue
		}

		if !strings.Contains(targetName, ".") {
			sourcePkgPath := sourceFQN[:strings.LastIndex(sourceFQN, ".")]
			sourceTypeName := sourceFQN[strings.LastIndex(sourceFQN, ".")+1:]

			targetPkgPath, ok := g.ruleSet.PackagePairs[sourcePkgPath]
			if !ok {
				slog.Error("No package pair for explicit rule", "sourceFQN", sourceFQN, "sourcePkgPath", sourcePkgPath)
				continue
			}

			underlyingTargetFQN := targetPkgPath + "." + sourceTypeName
			targetTypeInfo, err := g.walker.FindTypeByFQN(underlyingTargetFQN)
			if err != nil {
				slog.Error("Could not find underlying target for explicit alias", "targetFQN", underlyingTargetFQN, "error", err)
				continue
			}
			targetModelType := g.converter.ConvertToModel(targetTypeInfo)
			if targetModelType == nil {
				slog.Error("Failed to convert target for explicit alias", "fqn", underlyingTargetFQN)
				continue
			}

			g.AddTask(sourceModelType, targetModelType, true, targetName)
			slog.Debug("Added explicit alias task", "source", sourceFQN, "aliasName", targetName, "target", underlyingTargetFQN)
			g.processed[sourceFQN] = true
		} else {
			targetParts := strings.Split(targetName, ".")
			if len(targetParts) == 2 {
				targetAlias, targetTypeName := targetParts[0], targetParts[1]
				targetPkgPath, ok := g.ruleSet.PackageAliases[targetAlias]
				if !ok {
					slog.Error("Could not resolve target alias in explicit rule", "alias", targetAlias)
					continue
				}

				targetFQN := targetPkgPath + "." + targetTypeName
				targetTypeInfo, err := g.walker.FindTypeByFQN(targetFQN)
				if err != nil {
					slog.Error("Could not find target type for explicit FQN rule", "targetFQN", targetFQN, "error", err)
					continue
				}
				targetModelType := g.converter.ConvertToModel(targetTypeInfo)

				if targetModelType != nil {
					g.AddTask(sourceModelType, targetModelType, false, "")
					g.processed[sourceFQN] = true
					slog.Debug("Added explicit FQN-to-FQN conversion task", "source", sourceFQN, "target", targetFQN)
				}
			}
		}
	}

	g.runPackageDiscovery(g.ruleSet.PackagePairs)

	if g.ruleSet.BehaviorRules.Direction["*"] == "both" {
		slog.Debug("Handling bidirectional conversion")
		reversedPackagePairs := make(map[string]string)
		for source, target := range g.ruleSet.PackagePairs {
			reversedPackagePairs[target] = source
		}
		g.runPackageDiscovery(reversedPackagePairs)
	}

	slog.Debug("Finished discovering conversion tasks", "totalTasks", len(g.tasks))
	return nil
}

func (g *Generator) runPackageDiscovery(packagePairs map[string]string) {
	if len(packagePairs) == 0 {
		slog.Warn("No package pairing rules found for this discovery run.")
		return
	}

	for _, pkg := range g.walker.GetLoadedPackages() {
		targetPkgPath, isSourcePkg := packagePairs[pkg.PkgPath]
		if !isSourcePkg {
			continue
		}

		slog.Debug("Processing source package for tasks", "sourcePkg", pkg.PkgPath, "targetPkg", targetPkgPath)

		for _, typeName := range pkg.Types.Scope().Names() {
			obj := pkg.Types.Scope().Lookup(typeName)
			if obj == nil || !obj.Exported() {
				continue
			}
			if _, ok := obj.(*types.TypeName); !ok {
				continue
			}

			sourceFQN := (&model.Type{ImportPath: pkg.PkgPath, Name: typeName}).GetFQN()
			taskKey := fmt.Sprintf("%s->%s", sourceFQN, targetPkgPath)
			if g.processed[taskKey] {
				continue
			}

			sourceTypeInfo, err := g.walker.FindTypeByFQN(sourceFQN)
			if err != nil {
				slog.Error("Failed to find source type info", "fqn", sourceFQN, "error", err)
				continue
			}
			sourceModelType := g.converter.ConvertToModel(sourceTypeInfo)
			if sourceModelType == nil {
				continue
			}

			directTargetFQN := targetPkgPath + "." + sourceTypeInfo.Name
			directTargetTypeInfo, directErr := g.walker.FindTypeByFQN(directTargetFQN)

			if directErr == nil && directTargetTypeInfo != nil {
				directTargetModelType := g.convertAnalyzerTypeToModel(directTargetTypeInfo)
				if directTargetModelType != nil {
					g.AddTask(sourceModelType, directTargetModelType, false, "")
					g.processed[taskKey] = true
					slog.Debug("Added direct conversion task", "source", sourceFQN, "target", directTargetFQN)
					continue
				}
			} else {
				slog.Debug("Direct target type not found", "sourceFQN", sourceFQN, "directTargetFQN", directTargetFQN, "error", directErr)
			}

			predictedTargetTypeName := g.applyNamingRules(sourceTypeInfo.Name)

			if predictedTargetTypeName != sourceTypeInfo.Name {
				aliasTargetFQN := targetPkgPath + "." + sourceTypeInfo.Name
				aliasTargetTypeInfo, aliasErr := g.walker.FindTypeByFQN(aliasTargetFQN)

				if aliasErr == nil && aliasTargetTypeInfo != nil {
					aliasTargetModelType := g.convertAnalyzerTypeToModel(aliasTargetTypeInfo)
					if aliasTargetModelType != nil {
						g.AddTask(sourceModelType, aliasTargetModelType, true, predictedTargetTypeName)
						g.processed[taskKey] = true
						slog.Debug("Added alias generation task", "source", sourceFQN, "aliasName", predictedTargetTypeName, "target", aliasTargetFQN)
						continue
					}
				} else {
					slog.Debug("Alias target type not found", "sourceFQN", sourceFQN, "aliasTargetFQN", aliasTargetFQN, "error", aliasErr)
				}
			}
		}
	}
}

func (g *Generator) applyNamingRules(sourceName string) string {
	result := sourceName
	if g.ruleSet.NamingRules.SourcePrefix != "" && strings.HasPrefix(result, g.ruleSet.NamingRules.SourcePrefix) {
		result = strings.TrimPrefix(result, g.ruleSet.NamingRules.SourcePrefix)
	}
	if g.ruleSet.NamingRules.SourceSuffix != "" && strings.HasSuffix(result, g.ruleSet.NamingRules.SourceSuffix) {
		result = strings.TrimSuffix(result, g.ruleSet.NamingRules.SourceSuffix)
	}
	if g.ruleSet.NamingRules.TargetPrefix != "" {
		result = g.ruleSet.NamingRules.TargetPrefix + result
	}
	if g.ruleSet.NamingRules.TargetSuffix != "" {
		result = result + g.ruleSet.NamingRules.TargetSuffix
	}
	return result
}

func (g *Generator) convertAnalyzerTypeToModel(info *analyzer.TypeInfo) *model.Type {
	return g.converter.ConvertToModel(info)
}

// needsCustomStub determines if a conversion task needs a custom stub.
func (g *Generator) needsCustomStub(task *model.ConversionTask) bool {
	// If we can't generate automatic conversion for this task, it needs a stub
	if task.SourceType.Kind == model.TypeKindStruct && task.TargetType.Kind == model.TypeKindStruct {
		// Check if fields are compatible
		if !g.areStructsCompatible(task.SourceType, task.TargetType) {
			return true
		}
	}
	
	// Other complex type conversions that need manual implementation
	if g.isComplexConversion(task.SourceType, task.TargetType) {
		return true
	}
	
	return false
}

// areStructsCompatible checks if two structs are compatible for auto-conversion
func (g *Generator) areStructsCompatible(source, target *model.Type) bool {
	if source.Kind != model.TypeKindStruct || target.Kind != model.TypeKindStruct {
		return false
	}
	
	// Simple compatibility check - can be enhanced
	if len(source.Fields) == 0 || len(target.Fields) == 0 {
		return false
	}
	
	return true
}

// isComplexConversion determines if this is a complex conversion requiring manual implementation
func (g *Generator) isComplexConversion(source, target *model.Type) bool {
	// Check for complex nested structures, maps with custom types, etc.
	if source.Kind == model.TypeKindMap || target.Kind == model.TypeKindMap {
		return true
	}
	
	if source.Kind == model.TypeKindInterface || target.Kind == model.TypeKindInterface {
		return true
	}
	
	return false
}

// writeCustomStub writes a single custom conversion stub.
func (g *Generator) writeCustomStub(buf *bytes.Buffer, task *model.ConversionTask) {
	sourceType := g.getTypeString(task.SourceType)
	targetType := g.getTypeString(task.TargetType)
	funcName := g.namer.GetFunctionName(task.SourceType, task.TargetType)
	
	buf.WriteString(fmt.Sprintf("// %s converts from %s to %s.\n", funcName, sourceType, targetType))
	buf.WriteString("// Please implement this function.\n")
	buf.WriteString(fmt.Sprintf("func %s(from %s) %s {\n", funcName, sourceType, targetType))
	buf.WriteString("\t// TODO: Implement this custom conversion.\n")
	buf.WriteString(fmt.Sprintf("\tpanic(\"custom conversion not implemented: %s\")\n", funcName))
	buf.WriteString("}\n\n")
}