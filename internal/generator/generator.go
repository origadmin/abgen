package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"log/slog"
	"sort"
	"strings"

	"github.com/origadmin/abgen/internal/config"
	"github.com/origadmin/abgen/internal/model"
)

var simpleConverters = map[string]string{
	// Removed all entries from simpleConverters.
}

var conversionFunctions = map[string]string{ // Renamed from helperBasedConverters
	"string->time.Time": "ConvertStringToTime",
	"string->uuid.UUID": "ConvertStringToUUID",
	"time.Time->string": "ConvertTimeToString",
	"uuid.UUID->string": "ConvertUUIDToString",
}

var conversionFunctionBodies = map[string]string{ // Renamed from helperFunctionBodies
	"ConvertStringToTime": `
func ConvertStringToTime(s string) time.Time {
	t, _ := time.Parse(time.RFC3339, s)
	return t
}
`,
	"ConvertStringToUUID": `
func ConvertStringToUUID(s string) uuid.UUID {
	u, _ := uuid.Parse(s)
	return u
}
`,
	"ConvertTimeToString": `
func ConvertTimeToString(t time.Time) string {
	return t.Format(time.RFC3339)
}
`,
	"ConvertUUIDToString": `
func ConvertUUIDToString(u uuid.UUID) string {
	return u.String()
}
`,
}

type Generator struct {
	config                      *config.Config
	buf                         bytes.Buffer
	importMgr                   *ImportManager
	converter                   *TypeConverter
	namer                       *Namer
	aliasMap                    map[string]string
	requiredConversionFunctions map[string]bool // Renamed from requiredHelpers
	typeInfos                   map[string]*model.TypeInfo
	customStubs                 map[string]string
	involvedPackages            map[string]struct{}
}

func NewGenerator(config *config.Config) *Generator {
	g := &Generator{
		config:                      config,
		importMgr:                   NewImportManager(),
		aliasMap:                    make(map[string]string),
		requiredConversionFunctions: make(map[string]bool), // Initialize
		customStubs:                 make(map[string]string),
		involvedPackages:            make(map[string]struct{}),
	}
	g.namer = NewNamer(config, g.aliasMap)
	g.converter = NewTypeConverter()
	return g
}

func (g *Generator) Generate(typeInfos map[string]*model.TypeInfo) ([]byte, error) {
	g.typeInfos = typeInfos
	slog.Debug("Generating code", "type_count", len(g.typeInfos), "rules", len(g.config.ConversionRules))

	// Populate the set of involved packages
	for _, pkgPath := range g.config.RequiredPackages() {
		g.involvedPackages[pkgPath] = struct{}{}
	}

	if len(g.config.ConversionRules) == 0 {
		g.discoverImplicitConversionRules()
	}

	g.populateAliases()

	var bodyBuf bytes.Buffer
	g.buf = bodyBuf

	g.writeAliases()
	g.writeConversionFunctions()
	g.writeHelperFunctions()

	finalBuf := new(bytes.Buffer)
	g.writeHeaderAndPackageToBuffer(finalBuf)
	g.writeImportsToBuffer(finalBuf)
	finalBuf.Write(g.buf.Bytes())

	return format.Source(finalBuf.Bytes())
}

// CustomStubs returns the generated custom conversion stub functions.
func (g *Generator) CustomStubs() []byte {
	if len(g.customStubs) == 0 {
		return nil
	}

	var buf bytes.Buffer
	buf.WriteString("//go:build !abgen_source\n")
	buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// versions: %s\n", "abgen"))
	buf.WriteString(fmt.Sprintf("// source: %s\n\n", g.config.GenerationContext.DirectivePath))
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.getPackageName()))

	g.importMgr.WriteImportsToBuffer(&buf)

	buf.WriteString("\n// --- Custom Conversion Stubs ---\n")
	stubNames := make([]string, 0, len(g.customStubs))
	for name := range g.customStubs {
		stubNames = append(stubNames, name)
	}
	sort.Strings(stubNames)

	for _, name := range stubNames {
		buf.WriteString(g.customStubs[name])
		buf.WriteString("\n")
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		slog.Error("Failed to format custom stubs", "error", err)
		return buf.Bytes()
	}
	return formatted
}

func (g *Generator) writeHeaderAndPackageToBuffer(buf *bytes.Buffer) {
	pkgName := g.getPackageName()
	buf.WriteString("//go:build !abgen_source\n")
	buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// versions: %s\n", "abgen"))
	buf.WriteString(fmt.Sprintf("// source: %s\n\n", g.config.GenerationContext.DirectivePath))
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
}

func (g *Generator) writeImportsToBuffer(buf *bytes.Buffer) {
	imports := g.importMgr.GetAllImports()
	if len(imports) == 0 {
		return
	}
	buf.WriteString("import (\n")
	sort.Strings(imports)
	for _, importPath := range imports {
		alias := g.importMgr.GetAlias(importPath)
		buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, importPath))
	}
	buf.WriteString(")\n\n")
}

func (g *Generator) writeAliases() {
	type aliasPair struct {
		aliasName, fqn string
	}
	aliasesToWrite := make([]aliasPair, 0)
	for fqn, alias := range g.aliasMap {
		if _, exists := g.config.ExistingAliases[alias]; exists {
			continue
		}
		aliasesToWrite = append(aliasesToWrite, aliasPair{alias, fqn})
	}

	validAliases := make([]aliasPair, 0)
	for _, alias := range aliasesToWrite {
		if g.typeInfos[alias.fqn] != nil {
			validAliases = append(validAliases, alias)
		}
	}

	if len(validAliases) == 0 {
		return
	}

	sort.Slice(validAliases, func(i, j int) bool { return validAliases[i].aliasName < validAliases[j].aliasName })

	g.buf.WriteString("// Local type aliases for external types.\n")
	g.buf.WriteString("type (\n")

	for _, item := range validAliases {
		typeInfo := g.typeInfos[item.fqn]
		pkgAlias := g.importMgr.GetAlias(typeInfo.ImportPath)
		originalTypeName := fmt.Sprintf("%s.%s", pkgAlias, typeInfo.Name)
		g.buf.WriteString(fmt.Sprintf("\t%s = %s\n", item.aliasName, originalTypeName))
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) writeConversionFunctions() {
	rules := g.config.ConversionRules
	sort.Slice(rules, func(i, j int) bool { return rules[i].SourceType < rules[j].SourceType })

	for _, rule := range rules {
		sourceInfo := g.typeInfos[rule.SourceType]
		targetInfo := g.typeInfos[rule.TargetType]
		if sourceInfo == nil || targetInfo == nil {
			continue
		}
		g.generateConversionFunction(sourceInfo, targetInfo, rule)
	}
}

func (g *Generator) writeHelperFunctions() {
	if len(g.requiredConversionFunctions) == 0 {
		return
	}
	helpers := make([]string, 0, len(g.requiredConversionFunctions))
	for name := range g.requiredConversionFunctions {
		helpers = append(helpers, name)
	}
	sort.Strings(helpers)
	g.buf.WriteString("\n// --- Helper Functions ---\n")
	for _, name := range helpers {
		if body, ok := conversionFunctionBodies[name]; ok {
			g.buf.WriteString(body)
		}
	}
}

func (g *Generator) generateConversionFunction(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule) {
	g.doGenerateConversionFunction(sourceInfo, targetInfo, rule, false)
	if rule.Direction == config.DirectionBoth {
		reverseRule := &config.ConversionRule{
			SourceType: targetInfo.FQN(),
			TargetType: sourceInfo.FQN(),
			Direction:  config.DirectionOneway,
			FieldRules: config.FieldRuleSet{Ignore: make(map[string]struct{}), Remap: make(map[string]string)},
		}
		for from, to := range rule.FieldRules.Remap {
			reverseRule.FieldRules.Remap[to] = from
		}
		g.doGenerateConversionFunction(targetInfo, sourceInfo, reverseRule, true)
	}
}

func (g *Generator) doGenerateConversionFunction(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule, isReverse bool) {
	funcName := g.namer.GetFunctionName(sourceInfo, targetInfo)
	g.buf.WriteString(fmt.Sprintf("// %s converts %s to %s\n", funcName, g.getTypeString(sourceInfo), g.getTypeString(targetInfo)))
	g.buf.WriteString(fmt.Sprintf("func %s(from *%s) *%s {\n", funcName, g.getTypeString(sourceInfo), g.getTypeString(targetInfo)))
	g.buf.WriteString("\tif from == nil {\n\t\treturn nil\n\t}\n\n")
	if g.converter.IsStruct(sourceInfo) && g.converter.IsStruct(targetInfo) {
		g.generateStructToStructConversion(sourceInfo, targetInfo, rule)
	} else {
		g.buf.WriteString("\t// TODO: Implement non-struct conversion\n\treturn nil\n")
	}
	g.buf.WriteString("}\n\n")
}

func (g *Generator) generateStructToStructConversion(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule) {
	g.buf.WriteString("\tto := &" + g.getTypeString(targetInfo) + "{\n")
	for _, sourceField := range sourceInfo.Fields {
		if _, shouldIgnore := rule.FieldRules.Ignore[sourceField.Name]; shouldIgnore {
			continue
		}
		targetFieldName := sourceField.Name
		if remappedName, shouldRemap := rule.FieldRules.Remap[sourceField.Name]; shouldRemap {
			targetFieldName = remappedName
		}

		var targetField *model.FieldInfo
		// First, try for an exact (case-sensitive) match.
		for _, tf := range targetInfo.Fields {
			if tf.Name == targetFieldName {
				targetField = tf
				break
			}
		}
		// If no exact match, fall back to case-insensitive matching.
		if targetField == nil {
			for _, tf := range targetInfo.Fields {
				if strings.EqualFold(tf.Name, targetFieldName) {
					targetField = tf
					break
				}
			}
		}
		if targetField != nil {
			conversionExpr := g.getConversionExpression(sourceInfo, sourceField, targetInfo, targetField, "from")
			g.buf.WriteString(fmt.Sprintf("\t\t%s: %s,\n", targetField.Name, conversionExpr))
		}
	}
	g.buf.WriteString("\t}\n")
	g.buf.WriteString("\treturn to\n")
}

// isNumericPrimitive checks if a given primitive kind is a numeric type.
func isNumericPrimitive(kind string) bool {
	switch kind {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
		"float32", "float64",
		"complex64", "complex128":
		return true
	default:
		return false
	}
}

// canDirectlyConvertPrimitives checks if two primitive types can be directly converted in Go.
// This is a simplified check and might need to be more comprehensive for all Go rules.
func canDirectlyConvertPrimitives(sourceKind, targetKind string) bool {
	// Identical types can always be converted (no-op)
	if sourceKind == targetKind {
		return true
	}

	// Numeric types can generally be converted to other numeric types
	if isNumericPrimitive(sourceKind) && isNumericPrimitive(targetKind) {
		return true
	}

	// string and []byte, []rune can be converted
	if (sourceKind == "string" && (targetKind == "[]byte" || targetKind == "[]rune")) ||
		((sourceKind == "[]byte" || sourceKind == "[]rune") && targetKind == "string") {
		return true
	}

	// bool, string, and other non-numeric primitives usually cannot be directly converted to each other
	// unless they are identical.
	return false
}

// generatePrimitiveConversionStub generates a stub function for primitive type conversion.
func generatePrimitiveConversionStub(funcName, sourceTypeName, targetTypeName string) string {
	return fmt.Sprintf(`
// %s converts a %s to a %s.
// TODO: Implement the conversion logic for %s to %s.
func %s(from %s) %s {
	// Example: return %s(from) if direct conversion is possible and desired,
	// or implement custom logic.
	panic("not implemented") // TODO: Implement me
}
`, funcName, sourceTypeName, targetTypeName, sourceTypeName, targetTypeName, funcName, sourceTypeName, targetTypeName, targetTypeName)
}

func (g *Generator) getConversionExpression(
	parentSource *model.TypeInfo, sourceField *model.FieldInfo,
	parentTarget *model.TypeInfo, targetField *model.FieldInfo,
	fromVar string,
) string {
	sourceType := sourceField.Type
	targetType := targetField.Type

	sourceFieldExpr := fmt.Sprintf("%s.%s", fromVar, sourceField.Name)

	sourceKey := sourceType.UniqueKey()
	targetKey := targetType.UniqueKey()

	if sourceKey == targetKey {
		return sourceFieldExpr
	}

	// Check in the unified conversionFunctions map
	conversionKey := sourceKey + "->" + targetKey
	if funcName, ok := conversionFunctions[conversionKey]; ok {
		g.requiredConversionFunctions[funcName] = true
		// Add necessary imports for the helper function
		if strings.Contains(funcName, "Time") {
			g.importMgr.Add("time")
		}
		if strings.Contains(funcName, "UUID") {
			g.importMgr.Add("github.com/google/uuid")
		}
		return fmt.Sprintf("%s(%s)", funcName, sourceFieldExpr)
	}

	slog.Debug("Entering getConversionExpression",
		"sourceFQN", sourceKey,
		"targetFQN", targetKey,
		"field", sourceField.Name,
		"customFunctionRules", g.config.CustomFunctionRules)

	// Check for custom function rules from config
	customFuncKey := sourceKey + "->" + targetKey
	slog.Debug("Checking for custom function rule", "customFuncKey", customFuncKey, "sourceField", sourceField.Name, "sourceType", sourceType.Name, "targetType", targetType.Name)
	if customFuncName, ok := g.config.CustomFunctionRules[customFuncKey]; ok {
		slog.Debug("Found custom function rule", "customFuncKey", customFuncKey, "funcName", customFuncName)
		// We found a custom function defined by the user for this specific type conversion.
		// We don't need to add it to requiredConversionFunctions as it's assumed to be user-defined.
		return fmt.Sprintf("%s(%s)", customFuncName, sourceFieldExpr)
	}

	// Handle underlying types for named types that are not primitive
	if sourceType.Underlying != nil && targetType.Underlying != nil && sourceType.Underlying.UniqueKey() == targetType.Underlying.UniqueKey() {
		return fmt.Sprintf("%s(%s)", g.getTypeString(targetType), sourceFieldExpr)
	}
	if sourceType.Underlying != nil && sourceType.Underlying.UniqueKey() == targetKey {
		return fmt.Sprintf("%s(%s)", g.getTypeString(targetType), sourceFieldExpr)
	}
	if targetType.Underlying != nil && targetType.Underlying.UniqueKey() == sourceKey {
		return fmt.Sprintf("%s(%s)", g.getTypeString(targetType), sourceFieldExpr)
	}

	// Handle numeric primitive conversions (e.g., int to int32)
	if sourceType.Kind == model.Primitive && targetType.Kind == model.Primitive &&
		isNumericPrimitive(sourceType.Name) && isNumericPrimitive(targetType.Name) {
		return fmt.Sprintf("%s(%s)", g.getTypeString(targetType), sourceFieldExpr)
	}

	if sourceType.Kind == model.Primitive && targetType.Kind == model.Primitive {
		if canDirectlyConvertPrimitives(sourceType.Name, targetType.Name) {
			return fmt.Sprintf("%s(%s)", g.getTypeString(targetType), sourceFieldExpr)
		} else {
			// This case is for non-numeric primitives that need custom logic,
			// like converting a status string "active" to an integer status 1.
			// A stub function is generated for the user to implement.
			stubFuncName := g.namer.GetPrimitiveConversionStubName(parentSource, sourceField, parentTarget, targetField)
			if _, exists := g.customStubs[stubFuncName]; !exists {
				g.customStubs[stubFuncName] = generatePrimitiveConversionStub(
					stubFuncName,
					g.getTypeString(sourceType),
					g.getTypeString(targetType),
				)
			}
			return fmt.Sprintf("%s(%s)", stubFuncName, sourceFieldExpr)
		}
	}

	// Fallback to generating/using a dedicated conversion function for complex types (structs, slices, etc.)
	// This is the recursive part of the generation.
	funcName := g.namer.GetFunctionName(sourceType, targetType)
	return fmt.Sprintf("%s(%s)", funcName, sourceFieldExpr)
}

func (g *Generator) populateAliases() {
	visited := make(map[string]struct{})
	for _, rule := range g.config.ConversionRules {
		sourceInfo := g.typeInfos[rule.SourceType]
		targetInfo := g.typeInfos[rule.TargetType]
		if sourceInfo == nil || targetInfo == nil {
			continue
		}

		hasSourceSpecificRule := g.config.NamingRules.SourcePrefix != "" || g.config.NamingRules.SourceSuffix != ""
		hasTargetSpecificRule := g.config.NamingRules.TargetPrefix != "" || g.config.NamingRules.TargetSuffix != ""
		
		// Disambiguate if source and target have same name but different packages
		// and either source or target (or both) lack specific naming rules
		sourceNeedsDisambiguation := sourceInfo.Name == targetInfo.Name && sourceInfo.ImportPath != targetInfo.ImportPath && !hasSourceSpecificRule
		targetNeedsDisambiguation := sourceInfo.Name == targetInfo.Name && sourceInfo.ImportPath != targetInfo.ImportPath && !hasTargetSpecificRule

		g.createAliasesRecursively(sourceInfo, true, sourceNeedsDisambiguation, visited)
		g.createAliasesRecursively(targetInfo, false, targetNeedsDisambiguation, visited)
	}
}

func (g *Generator) createAliasesRecursively(info *model.TypeInfo, isSource, disambiguate bool, visited map[string]struct{}) {
	if info == nil || (info.UniqueKey() == "" && info.Kind != model.Primitive) {
		return
	}

	// Filter out types from packages not involved in the conversion.
	if info.ImportPath != "" {
		if _, ok := g.involvedPackages[info.ImportPath]; !ok {
			return
		}
	}

	key := info.UniqueKey()

	if _, ok := visited[key]; ok {
		return
	}
	visited[key] = struct{}{}

	alias := g.namer.GetAlias(info, isSource, disambiguate)
	if _, exists := g.config.ExistingAliases[alias]; !exists {
		if _, exists := g.aliasMap[key]; !exists {
			g.aliasMap[key] = alias
		}
	} else {
		g.aliasMap[key] = alias
	}

	if info.ImportPath != "" && !g.isCurrentPackage(info.ImportPath) {
		g.importMgr.Add(info.ImportPath)
	}

	if info.Kind == model.Struct {
		for _, field := range info.Fields {
			g.createAliasesRecursively(field.Type, isSource, disambiguate, visited)
		}
	}
	if info.Underlying != nil {
		g.createAliasesRecursively(info.Underlying, isSource, disambiguate, visited)
	}
}

func (g *Generator) getTypeString(info *model.TypeInfo) string {
	if info == nil {
		return "interface{}"
	}
	if info.Kind == model.Primitive {
		return info.Name
	}

	key := info.UniqueKey()

	if alias, ok := g.aliasMap[key]; ok {
		return alias
	}

	for alias, existingFQN := range g.config.ExistingAliases {
		if existingFQN == key {
			return alias
		}
	}

	return info.Name
}

func (g *Generator) discoverImplicitConversionRules() {
	typesByPackage := make(map[string][]*model.TypeInfo)
	for _, info := range g.typeInfos {
		if info.IsNamedType() && info.Kind == model.Struct {
			typesByPackage[info.ImportPath] = append(typesByPackage[info.ImportPath], info)
		}
	}
	for _, pair := range g.config.PackagePairs {
		sourceTypes := typesByPackage[pair.SourcePath]
		targetTypes := typesByPackage[pair.TargetPath]
		sort.Slice(sourceTypes, func(i, j int) bool { return sourceTypes[i].FQN() < sourceTypes[j].FQN() })
		sort.Slice(targetTypes, func(i, j int) bool { return targetTypes[i].FQN() < targetTypes[j].FQN() })
		for _, sourceType := range sourceTypes {
			for _, targetType := range targetTypes {
				if sourceType.Name == targetType.Name {
					rule := &config.ConversionRule{
						SourceType: sourceType.FQN(),
						TargetType: targetType.FQN(),
						Direction:  config.DirectionBoth,
						FieldRules: config.FieldRuleSet{Ignore: make(map[string]struct{}), Remap: make(map[string]string)},
					}
					g.config.ConversionRules = append(g.config.ConversionRules, rule)
				}
			}
		}
	}
	sort.Slice(g.config.ConversionRules, func(i, j int) bool {
		if g.config.ConversionRules[i].SourceType != g.config.ConversionRules[j].SourceType {
			return g.config.ConversionRules[i].SourceType < g.config.ConversionRules[j].SourceType
		}
		return g.config.ConversionRules[i].TargetType < g.config.ConversionRules[j].TargetType
	})
}

func (g *Generator) getPackageName() string {
	if g.config.GenerationContext.PackageName != "" {
		return g.config.GenerationContext.PackageName
	}
	return "generated"
}

func (g *Generator) isCurrentPackage(importPath string) bool {
	return importPath == g.config.GenerationContext.PackagePath
}
