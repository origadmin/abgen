// Package generator is responsible for generating the Go source code based on the
// analysis results from the AST walker.
package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"log/slog"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/origadmin/abgen/internal/ast"
	"github.com/origadmin/abgen/internal/types"
)

// conversionTask represents a single function generation task.
type conversionTask struct {
	Source *types.TypeInfo
	Target *types.TypeInfo
}

// Generator holds the state for code generation.
type Generator struct {
	walker           *ast.PackageWalker
	config           *types.ConversionConfig
	buf              bytes.Buffer
	customBuf        bytes.Buffer // Buffer for custom.gen.go
	imports          *ImportManager
	generatedAliases map[string]string
	tasks            []conversionTask
	generatedTasks   map[string]bool
	customTasks      map[string]conversionTask // Tasks for custom.gen.go
	localTypeAliases map[string]string         // Added: Map of local type alias names to their FQNs
}

// NewGenerator creates a new Generator instance.
func NewGenerator(walker *ast.PackageWalker) *Generator {
	return &Generator{
		walker:           walker,
		localTypeAliases: walker.GetLocalTypeNameToFQN(), // Added: Initialize localTypeAliases
	}
}

// Generate produces the Go source code for the conversions.
func (g *Generator) Generate() ([]byte, error) {
	g.config = g.walker.Config()
	g.imports = NewImportManager()
	g.generatedAliases = make(map[string]string)
	g.tasks = make([]conversionTask, 0)
	g.generatedTasks = make(map[string]bool)
	g.customTasks = make(map[string]conversionTask)

	// 1. Discover all tasks (dry run)
	g.addInitialTasks()
	g.discoverAllTasks()

	// 2. Write package and header
	pkgName := path.Base(g.config.ContextPackagePath)
	g.buf.WriteString("package " + pkgName + "\n\n")
	g.buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n\n")

	// 3. Write imports based on all discovered tasks
	g.collectAndWriteImports()

	// 4. Write type aliases based on all discovered tasks
	g.generateTypeAliases()

	// 5. Write the actual conversion functions
	g.generateAllConversionFunctions()

	// 6. Generate custom stubs if any
	g.generateCustomStubs()

	return format.Source(g.buf.Bytes())
}

// CustomStubs returns the generated custom conversion stubs.
func (g *Generator) CustomStubs() []byte {
	if g.customBuf.Len() == 0 {
		return nil
	}
	formatted, err := format.Source(g.customBuf.Bytes())
	if err != nil {
		// Log the error but return unformatted bytes to allow inspection
		slog.Error("Error formatting custom stubs", "error", err)
		return g.customBuf.Bytes()
	}
	return formatted
}

func (g *Generator) addInitialTasks() {
	for _, pair := range g.config.Pairs {
		sourceInfo, _ := g.walker.Resolve(pair.Source.Type)
		targetInfo, _ := g.walker.Resolve(pair.Target.Type)
		if sourceInfo != nil && targetInfo != nil {
			// Assign LocalAlias if available from the TypeEndpoint
			if pair.Source.AliasType != "" {
				sourceInfo.LocalAlias = pair.Source.AliasType
			}
			if pair.Target.AliasType != "" {
				targetInfo.LocalAlias = pair.Target.AliasType
			}

			g.addTask(sourceInfo, targetInfo)
			if g.config.Direction == "both" {
				g.addTask(targetInfo, sourceInfo)
			}
		}
	}
}

func (g *Generator) addTask(source, target *types.TypeInfo) {
	taskKey := g.getTaskKey(source, target)
	if !g.generatedTasks[taskKey] {
		g.tasks = append(g.tasks, conversionTask{Source: source, Target: target})
		g.generatedTasks[taskKey] = true
	}
}

func (g *Generator) getTaskKey(source, target *types.TypeInfo) string {
	return source.ImportPath + "." + source.Name + "->" + target.ImportPath + "." + target.Name
}

// discoverAllTasks runs through the task queue to discover all sub-tasks without generating code.
func (g *Generator) discoverAllTasks() {
	for i := 0; i < len(g.tasks); i++ { // Loop expands as new tasks are added
		task := g.tasks[i]
		source, target := task.Source, task.Target

		// Only need to discover sub-tasks for struct-to-struct conversions
		if len(source.Fields) > 0 && len(target.Fields) > 0 {
			for _, field := range source.Fields {
				targetFieldName := field.Name
				if remap, ok := g.config.RemapFields[source.ImportPath+"."+source.Name+"#"+field.Name]; ok {
					targetFieldName = remap
				}
				if targetField, ok := findField(target.Fields, targetFieldName); ok {
					// If types are different, a sub-task is needed
					if field.Type != targetField.Type {
						sourceFieldType, _ := g.walker.Resolve(field.Type)
						targetFieldType, _ := g.walker.Resolve(targetField.Type)
						if sourceFieldType != nil && targetFieldType != nil {
							g.addTask(sourceFieldType, targetFieldType)
						}
					}
				}
			}
		}
	}
}

func (g *Generator) collectAndWriteImports() {
	for _, task := range g.tasks {
		g.addImportFromInfo(task.Source)
		g.addImportFromInfo(task.Target)
	}

	if len(g.imports.imports) == 0 {
		return
	}
	paths := make([]string, 0, len(g.imports.imports))
	for p := range g.imports.imports {
		paths = append(paths, p)
	}
	sort.Strings(paths)

	g.buf.WriteString("import (\n")
	for _, p := range paths {
		alias := g.imports.imports[p]
		g.buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, p))
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) generateTypeAliases() {
	aliasesToGenerate := make(map[string]string)

	allInfos := make(map[string]*types.TypeInfo)
	for _, task := range g.tasks {
		allInfos[g.getTaskKey(task.Source, task.Source)] = task.Source
		allInfos[g.getTaskKey(task.Target, task.Target)] = task.Target
	}

	for _, info := range allInfos {
		if g.isExternalType(info) {
			prefix, suffix := g.getPrefixSuffix(info)
			aliasName := g.getFuncNamePart(info, prefix, suffix) // e.g., "RoleBilateral" for types.Role
			fqn := info.ImportPath + "." + info.Name

			// Check if this alias is already defined in the directives.go file
			if existingFQN, ok := g.localTypeAliases[aliasName]; ok && existingFQN == fqn {
				// If the alias name and its FQN match a locally defined alias, skip generating it
				continue
			}

			if _, exists := aliasesToGenerate[fqn]; !exists {
				pkgAlias := g.imports.Add(info.ImportPath)
				aliasesToGenerate[fqn] = fmt.Sprintf("\t%s = %s.%s\n", aliasName, pkgAlias, info.Name)
				g.generatedAliases[fqn] = aliasName
			}

			// Also generate slice aliases for struct types
			if len(info.Fields) > 0 && !g.isSliceType(info) {
				// The base name for pluralization is the original type name from info
				baseNameForPluralization := info.Name // e.g., "Resource" for types.Resource

				// If suffix exists, use Name + "s" + Suffix
				sliceAliasName := prefix + baseNameForPluralization + "s" + suffix

				// Check if this slice alias name conflicts with a locally defined alias
				if _, exists := g.localTypeAliases[sliceAliasName]; exists {
					// If a local alias with the same name exists, skip generating this slice alias
					continue
				}

				sliceFqn := info.ImportPath + "." + info.Name + "Slice"
				sliceAliasDef := fmt.Sprintf("\t%s = []*%s  // Array/slice alias\n", sliceAliasName, aliasName)
				if _, exists := aliasesToGenerate[sliceFqn]; !exists {
					aliasesToGenerate[sliceFqn] = sliceAliasDef
					g.generatedAliases[sliceFqn] = sliceAliasName
				}
			}
		}
	}

	if len(aliasesToGenerate) == 0 {
		return
	}

	g.buf.WriteString("// Local type aliases for external types.\n")
	g.buf.WriteString("type (\n")
	var sortedAliases []string
	for _, aliasDef := range aliasesToGenerate {
		sortedAliases = append(sortedAliases, aliasDef)
	}
	sort.Strings(sortedAliases)
	for _, aliasDef := range sortedAliases {
		g.buf.WriteString(aliasDef)
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) generateAllConversionFunctions() {
	// Sort tasks for consistent function generation order
	sort.Slice(g.tasks, func(i, j int) bool {
		return g.getTaskKey(g.tasks[i].Source, g.tasks[j].Target) < g.getTaskKey(g.tasks[j].Source, g.tasks[j].Target)
	})

	for _, task := range g.tasks {
		g.generateSingleConversionFunc(task.Source, task.Target)
	}
}

// isSliceType checks if a TypeInfo represents a slice type.
func (g *Generator) isSliceType(info *types.TypeInfo) bool {
	return strings.HasPrefix(info.Name, "[]")
}

// getSliceElementType extracts the element type string and TypeInfo from a slice TypeInfo.
func (g *Generator) getSliceElementType(info *types.TypeInfo) (string, *types.TypeInfo) {
	if !g.isSliceType(info) {
		return "", nil
	}
	elemTypeStr := strings.TrimPrefix(info.Name, "[]")
	elemInfo, _ := g.walker.Resolve(elemTypeStr)
	return elemTypeStr, elemInfo
}

func (g *Generator) generateSingleConversionFunc(source, target *types.TypeInfo) {
	isSourceSlice := g.isSliceType(source)
	isTargetSlice := g.isSliceType(target)

	if isSourceSlice && isTargetSlice {
		_, sourceElemInfo := g.getSliceElementType(source)
		_, targetElemInfo := g.getSliceElementType(target)

		// Only generate slice-to-slice conversion if element types are structs
		// and they are not basic types (e.g., []int to []string should be handled by auto-conversion or custom)
		if sourceElemInfo != nil && targetElemInfo != nil && len(sourceElemInfo.Fields) > 0 && len(targetElemInfo.Fields) > 0 {
			g.generateSliceToSliceFunc(source, target, sourceElemInfo, targetElemInfo)
			return
		}
	}

	isSourceStruct := len(source.Fields) > 0
	isTargetStruct := len(target.Fields) > 0

	if isSourceStruct && isTargetStruct {
		g.generateStructToStructFunc(source, target)
	} else if g.canAutoConvert(source, target) {
		g.generateAutoConversionFunc(source, target)
	} else {
		taskKey := g.getTaskKey(source, target)
		g.customTasks[taskKey] = conversionTask{Source: source, Target: target}
	}
}

func (g *Generator) generateSliceToSliceFunc(sourceSlice, targetSlice, sourceElem, targetElem *types.TypeInfo) {
	sourcePrefix, sourceSuffix := g.getPrefixSuffix(sourceSlice)
	targetPrefix, targetSuffix := g.getPrefixSuffix(targetSlice)
	sourceNamePart := g.getFuncNamePart(sourceSlice, sourcePrefix, sourceSuffix)
	targetNamePart := g.getFuncNamePart(targetSlice, targetPrefix, targetSuffix)
	funcName := "Convert" + capitalize(sourceNamePart) + "To" + capitalize(targetNamePart)

	// Use the full type string for the function signature
	sourceTypeStr := g.getTypeName(sourceSlice)
	targetTypeStr := g.getTypeName(targetSlice)

	elemConvFuncName := g.getConversionFunctionName(sourceElem, targetElem)

	g.buf.WriteString(fmt.Sprintf("// %s converts a %s to a %s.\n", funcName, sourceTypeStr, targetTypeStr))
	g.buf.WriteString(fmt.Sprintf("func %s(from %s) %s {\n", funcName, sourceTypeStr, targetTypeStr))
	g.buf.WriteString("\tif from == nil {\n\t\treturn nil\n\t}\n")
	g.buf.WriteString(fmt.Sprintf("\tto := make(%s, len(from))\n", targetTypeStr))
	g.buf.WriteString("\tfor i, item := range from {\n")
	g.buf.WriteString(fmt.Sprintf("\t\tto[i] = %s(item)\n", elemConvFuncName))
	g.buf.WriteString("\t}\n")
	g.buf.WriteString("\treturn to\n}\n\n")
}

func (g *Generator) generateStructToStructFunc(source, target *types.TypeInfo) {
	sourcePrefix, sourceSuffix := g.getPrefixSuffix(source)
	targetPrefix, targetSuffix := g.getPrefixSuffix(target)
	sourceNamePart := g.getFuncNamePart(source, sourcePrefix, sourceSuffix)
	targetNamePart := g.getFuncNamePart(target, targetPrefix, targetSuffix)
	funcName := "Convert" + capitalize(sourceNamePart) + "To" + capitalize(targetNamePart)

	sourceTypeStr := g.getTypeName(source)
	targetTypeStr := g.getTypeName(target)

	// Determine if we need pointers for function signature
	sourceParam := "*" + sourceTypeStr
	targetReturn := "*" + targetTypeStr
	if g.isSliceType(source) {
		sourceParam = sourceTypeStr
	}
	if g.isSliceType(target) {
		targetReturn = targetTypeStr
	}

	g.buf.WriteString(fmt.Sprintf("// %s converts a %s to a %s.\n", funcName, sourceParam, targetReturn))
	g.buf.WriteString(fmt.Sprintf("func %s(from %s) %s {\n", funcName, sourceParam, targetReturn))

	if g.isSliceType(source) {
		g.buf.WriteString("\tif from == nil {\n\t\treturn nil\n\t}\n")
		g.buf.WriteString(fmt.Sprintf("\tto := make(%s, len(from))\n", targetReturn))
		g.buf.WriteString("\tfor i, item := range from {\n")
		elemConvFuncName := g.getConversionFunctionName(source, target)
		g.buf.WriteString(fmt.Sprintf("\t\tto[i] = %s(item)\n", elemConvFuncName))
		g.buf.WriteString("\t}\n")
	} else {
		g.buf.WriteString("\tif from == nil {\n\t\treturn nil\n\t}\n")
		g.buf.WriteString(fmt.Sprintf("\tto := &%s{}\n\n", targetTypeStr))
		for _, field := range source.Fields {
			g.handleFieldAssignment(field, source, target)
		}
	}

	g.buf.WriteString("\treturn to\n}\n\n")
}

func (g *Generator) handleFieldAssignment(sourceField types.StructField, sourceInfo, targetInfo *types.TypeInfo) {
	fqnField := sourceInfo.ImportPath + "." + sourceInfo.Name + "#" + sourceField.Name
	if g.config.IgnoreFields[fqnField] {
		return
	}
	targetFieldName := sourceField.Name
	if remap, ok := g.config.RemapFields[fqnField]; ok {
		targetFieldName = remap
	}
	targetField, ok := findField(targetInfo.Fields, targetFieldName)
	if !ok { // Corrected: if target field is NOT found, then return
		return
	}

	sourceFieldType, _ := g.walker.Resolve(sourceField.Type)
	targetFieldType, _ := g.walker.Resolve(targetField.Type)

	convFuncName := g.getConversionFunctionName(sourceFieldType, targetFieldType)

	sourceDeref := ""
	if sourceField.IsPointer && isBasicType(sourceFieldType) {
		sourceDeref = "*"
	}

	// Determine the assignment string
	var assignmentStr string
	if convFuncName == "" {
		// Direct assignment, no function call, no extra parentheses
		assignmentStr = fmt.Sprintf("%sfrom.%s", sourceDeref, sourceField.Name)
	} else {
		// Function call, wrap in parentheses if needed (e.g., for pointer conversion)
		assignmentStr = fmt.Sprintf("%s(%sfrom.%s)", convFuncName, sourceDeref, sourceField.Name)
	}

	if targetField.IsPointer && !isBasicType(targetFieldType) && !strings.HasPrefix(g.getConversionFunctionSignature(sourceFieldType, targetFieldType), "*") {
		assignmentStr = "&" + assignmentStr
	}

	g.buf.WriteString(fmt.Sprintf("\tto.%s = %s\n", targetFieldName, assignmentStr))
}

func (g *Generator) getConversionFunctionName(source, target *types.TypeInfo) string {
	if source.ImportPath == target.ImportPath && source.Name == target.Name {
		return "" // Direct assignment
	}

	// If both are slice types, get the conversion function for their elements
	if g.isSliceType(source) && g.isSliceType(target) {
		_, sourceElemInfo := g.getSliceElementType(source)
		_, targetElemInfo := g.getSliceElementType(target)

		if sourceElemInfo != nil && targetElemInfo != nil {
			return g.getConversionFunctionName(sourceElemInfo, targetElemInfo)
		}
	}

	sourcePrefix, sourceSuffix := g.getPrefixSuffix(source)
	targetPrefix, targetSuffix := g.getPrefixSuffix(target)
	sourcePart := g.getFuncNamePart(source, sourcePrefix, sourceSuffix)
	targetPart := g.getFuncNamePart(target, targetPrefix, targetSuffix)

	return "Convert" + capitalize(sourcePart) + "To" + capitalize(targetPart)
}

func (g *Generator) getConversionFunctionSignature(source, target *types.TypeInfo) string {
	targetTypeStr := g.getTypeName(target)
	if isBasicType(target) && !target.IsPointer {
		return targetTypeStr
	}
	return "*" + targetTypeStr
}

func (g *Generator) canAutoConvert(source, target *types.TypeInfo) bool {
	s, t := source.Name, target.Name
	if source.ImportPath == "time" && t == "string" {
		return true
	}
	if s == "string" && target.ImportPath == "time" {
		return true
	}
	if types.IsNumberType(s) && t == "string" {
		return true
	}
	if s == "string" && types.IsNumberType(t) {
		return true
	}
	return false
}

func (g *Generator) generateAutoConversionFunc(source, target *types.TypeInfo) {
	funcName := g.getConversionFunctionName(source, target)
	sourceTypeStr := g.getTypeName(source)
	targetTypeStr := g.getTypeName(target)

	g.buf.WriteString(fmt.Sprintf("// %s converts %s to %s.\n", funcName, sourceTypeStr, targetTypeStr))
	g.buf.WriteString(fmt.Sprintf("func %s(from %s) %s {\n", funcName, sourceTypeStr, targetTypeStr))

	switch {
	case source.ImportPath == "time" && target.Name == "string":
		g.imports.Add("time")
		g.buf.WriteString("\treturn from.Format(time.RFC3339)\n")
	case source.Name == "string" && target.ImportPath == "time":
		g.imports.Add("time")
		g.buf.WriteString("\tt, _ := time.Parse(time.RFC3339, from)\n")
		g.buf.WriteString("\treturn t\n")
	case source.Name == "string" && types.IsNumberType(target.Name):
		g.imports.Add("strconv")
		g.buf.WriteString(fmt.Sprintf("\ti, _ := strconv.Atoi(from)\n\treturn %s(i)\n", target.Name))
	case types.IsNumberType(source.Name) && target.Name == "string":
		g.imports.Add("strconv")
		g.buf.WriteString("\treturn strconv.Itoa(int(from))\n")
	}

	g.buf.WriteString("}\n\n")
}

func (g *Generator) generateCustomStubs() {
	if len(g.customTasks) == 0 {
		return
	}
	pkgName := path.Base(g.config.ContextPackagePath)
	g.customBuf.WriteString("package " + pkgName + "\n\n")
	g.customBuf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	g.customBuf.WriteString("// This file is meant to be edited by hand to implement custom conversions.\n\n")

	// Collect imports for custom stubs
	customImports := NewImportManager()
	for _, task := range g.customTasks {
		// Correctly add imports from task.Source and task.Target to customImports
		if task.Source != nil && task.Source.ImportPath != "" && task.Source.ImportPath != "builtin" && task.Source.ImportPath != g.config.ContextPackagePath {
			customImports.Add(task.Source.ImportPath)
		}
		if task.Target != nil && task.Target.ImportPath != "" && task.Target.ImportPath != "builtin" && task.Target.ImportPath != g.config.ContextPackagePath {
			customImports.Add(task.Target.ImportPath)
		}
	}

	if len(customImports.imports) > 0 {
		paths := make([]string, 0, len(customImports.imports))
		for p := range customImports.imports {
			paths = append(paths, p)
		}
		sort.Strings(paths)

		g.customBuf.WriteString("import (\n")
		for _, p := range paths {
			alias := customImports.imports[p]
			g.customBuf.WriteString(fmt.Sprintf("\t%s %q\n", alias, p))
		}
		g.customBuf.WriteString(")\n\n")
	}

	g.customBuf.WriteString("// --- Custom Conversion Stubs ---\n")
	g.customBuf.WriteString("// Implement these functions in this file.\n\n")

	for _, task := range g.customTasks {
		funcName := g.getConversionFunctionName(task.Source, task.Target)
		sourceTypeStr := g.getTypeName(task.Source)
		targetTypeStr := g.getTypeName(task.Target)

		g.customBuf.WriteString(fmt.Sprintf("// %s converts %s to %s.\n", funcName, sourceTypeStr, targetTypeStr))
		g.customBuf.WriteString(fmt.Sprintf("func %s(from %s) %s {\n", funcName, sourceTypeStr, targetTypeStr))
		g.customBuf.WriteString(fmt.Sprintf("\t// TODO: Implement this custom conversion\n"))
		g.customBuf.WriteString(fmt.Sprintf("\tpanic(\"custom conversion not implemented: %s\")\n", funcName))
		g.customBuf.WriteString("}\n\n")
	}
}

func (g *Generator) addImportFromInfo(info *types.TypeInfo) {
	if info != nil && info.ImportPath != "" && info.ImportPath != "builtin" && info.ImportPath != g.config.ContextPackagePath {
		g.imports.Add(info.ImportPath)
	}
}

func (g *Generator) getPrefixSuffix(info *types.TypeInfo) (prefix, suffix string) {
	if info == nil {
		return "", ""
	}
	if info.ImportPath == g.config.Source.Package {
		return g.config.Source.Prefix, g.config.Source.Suffix
	}
	if info.ImportPath == g.config.Target.Package {
		return g.config.Target.Prefix, g.config.Target.Suffix
	}
	return "", ""
}

func (g *Generator) getFuncNamePart(typeInfo *types.TypeInfo, prefix, suffix string) string {
	name := typeInfo.Name

	// If it's a slice type, get the element name first
	if strings.HasPrefix(name, "[]") {
		name = strings.TrimPrefix(name, "[]")
	}
	if strings.HasPrefix(name, "*") {
		name = strings.TrimPrefix(name, "*")
	}

	// If LocalAlias exists and it's not a basic type, we should apply prefix/suffix
	// if they are configured for the target package
	if typeInfo.LocalAlias != "" {
		if !isBasicType(typeInfo) && (prefix != "" || suffix != "") {
			// Check if this type belongs to the target package and needs suffix
			if typeInfo.ImportPath == g.config.Target.Package {
				return typeInfo.LocalAlias
			}
			// For source types with alias, we might need to apply prefix/suffix
			baseAlias := typeInfo.LocalAlias
			if strings.HasPrefix(baseAlias, prefix) && strings.HasSuffix(baseAlias, suffix) {
				return baseAlias // Already has the prefix/suffix
			}
			// Remove any existing prefix/suffix from the local alias and apply new ones
			cleanName := strings.TrimPrefix(baseAlias, prefix)
			cleanName = strings.TrimSuffix(cleanName, suffix)
			return prefix + cleanName + suffix
		}
		return typeInfo.LocalAlias
	}

	if isBasicType(typeInfo) {
		return name
	}
	if prefix != "" || suffix != "" {
		return prefix + name + suffix
	}
	return name
}

func (g *Generator) getTypeName(typeInfo *types.TypeInfo) string {
	// If it's a local alias (defined in the directive file), use it directly
	if typeInfo.LocalAlias != "" {
		return typeInfo.LocalAlias
	}

	// If a generated alias exists for the FQN, use it
	fqn := typeInfo.ImportPath + "." + typeInfo.Name
	if alias, ok := g.generatedAliases[fqn]; ok {
		return alias
	}

	// Handle slice types: recursively get the element type name
	if g.isSliceType(typeInfo) {
		_, elemInfo := g.getSliceElementType(typeInfo)
		if elemInfo != nil {
			// Get prefix and suffix for the element info
			prefix, suffix := g.getPrefixSuffix(elemInfo)

			// The base name for pluralization is the original element type name (e.g., "Role" from "types.Role")
			baseNameForPluralization := elemInfo.Name

			// If suffix exists, use Name + "s" + Suffix
			sliceAliasName := prefix + baseNameForPluralization + suffix

			sliceFqn := typeInfo.ImportPath + "." + sliceAliasName
			g.generatedAliases[sliceFqn] = sliceAliasName
			return sliceAliasName
		}
		// Fallback if element info not found - return raw slice type
		return typeInfo.Name
	}

	// For external types, add import and use package alias
	if g.isExternalType(typeInfo) {
		pkgAlias := g.imports.Add(typeInfo.ImportPath)
		return pkgAlias + "." + typeInfo.Name
	}

	// For internal types or basic types, just use the name
	return typeInfo.Name
}

func (g *Generator) findCustomRule(sourceType, targetType *types.TypeInfo) string {
	for _, rule := range g.config.CustomRules {
		if rule.SourceTypeName == sourceType.Name && rule.TargetTypeName == targetType.Name {
			return rule.ConvertFunc
		}
	}
	return ""
}

func (g *Generator) isExternalType(info *types.TypeInfo) bool {
	return info.ImportPath != "" && info.ImportPath != "builtin" && info.ImportPath != g.config.ContextPackagePath
}

func isBasicType(info *types.TypeInfo) bool {
	if info == nil {
		return false
	}
	if types.IsPrimitiveType(info.Name) && info.ImportPath == "builtin" {
		return true
	}
	if info.ImportPath == "time" && info.Name == "Time" {
		return true
	}
	return false
}

func capitalize(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func findField(fields []types.StructField, name string) (types.StructField, bool) {
	for _, field := range fields {
		if strings.EqualFold(field.Name, name) {
			return field, true
		}
	}
	return types.StructField{}, false
}

func splitFQN(fqn string) (pkgPath, typeName string) {
	lastDot := strings.LastIndex(fqn, ".")
	if lastDot == -1 {
		return "", fqn
	}
	return fqn[:lastDot], fqn[lastDot+1:]
}

type ImportManager struct {
	imports map[string]string
}

func NewImportManager() *ImportManager {
	return &ImportManager{imports: make(map[string]string)}
}

func (im *ImportManager) Add(importPath string) string {
	if alias, exists := im.imports[importPath]; exists {
		return alias
	}
	alias := path.Base(importPath)
	originalAlias := alias
	counter := 1
	for {
		isConflict := false
		for _, existingAlias := range im.imports {
			if existingAlias == alias {
				isConflict = true
				alias = originalAlias + strconv.Itoa(counter)
				counter++
				break
			}
		}
		if !isConflict {
			break
		}
	}
	im.imports[importPath] = alias
	return alias
}
