package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"log/slog"
	"sort"
	"strings"

	"github.com/origadmin/abgen/internal/config"
	"github.com/origadmin/abgen/internal/model"
)

var simpleConverters = map[string]string{
	// Removed all entries from simpleConverters.
}

var conversionFunctions = map[string]string{ // Renamed from helperBasedConverters
	"string->time.Time": "ConvertStringToTime",
	"string->uuid.UUID": "ConvertStringToUUID",
	"time.Time->string": "ConvertTimeToString",
	"uuid.UUID->string": "ConvertUUIDToString",
}

var conversionFunctionBodies = map[string]string{ // Renamed from helperFunctionBodies
	"ConvertStringToTime": `
func ConvertStringToTime(s string) time.Time {
	t, _ := time.Parse(time.RFC3339, s)
	return t
}
`,
	"ConvertStringToUUID": `
func ConvertStringToUUID(s string) uuid.UUID {
	u, _ := uuid.Parse(s)
	return u
}
`,
	"ConvertTimeToString": `
func ConvertTimeToString(t time.Time) string {
	return t.Format(time.RFC3339)
}
`,
	"ConvertUUIDToString": `
func ConvertUUIDToString(u uuid.UUID) string {
	return u.String()
}
`,
}

type Generator struct {
	config                      *config.Config
	buf                         bytes.Buffer
	importMgr                   *ImportManager
	converter                   *TypeConverter
	namer                       *Namer
	aliasMap                    map[string]string
	requiredAliases             map[string]struct{} // 新增：存储所有需要生成别名声明的 TypeInfo.UniqueKey()
	requiredConversionFunctions map[string]bool
	typeInfos                   map[string]*model.TypeInfo
	customStubs                 map[string]string
	involvedPackages            map[string]struct{}
}

func NewGenerator(config *config.Config) *Generator {
	g := &Generator{
		config:                      config,
		importMgr:                   NewImportManager(),
		aliasMap:                    make(map[string]string),
		requiredAliases:             make(map[string]struct{}), // 初始化
		requiredConversionFunctions: make(map[string]bool),
		customStubs:                 make(map[string]string),
		involvedPackages:            make(map[string]struct{}),
	}
	g.converter = NewTypeConverter()
	g.namer = NewNamer(config, g.aliasMap)
	return g
}

func (g *Generator) Generate(typeInfos map[string]*model.TypeInfo) ([]byte, error) {
	g.typeInfos = typeInfos
	slog.Debug("Generating code", "type_count", len(g.typeInfos), "initial_rules", len(g.config.ConversionRules))

	// Populate the set of involved packages early on.
	for _, pkgPath := range g.config.RequiredPackages() {
		g.involvedPackages[pkgPath] = struct{}{}
	}

	// If no explicit conversion rules are defined, discover them from package pairs.
	// This is the crucial step to enable `pair:packages` to work.
	if len(g.config.ConversionRules) == 0 {
		g.discoverImplicitConversionRules()
		slog.Debug("Implicit rule discovery finished", "discovered_rules", len(g.config.ConversionRules))
	}

	g.populateAliases()

	var bodyBuf bytes.Buffer
	g.buf = bodyBuf

	g.writeAliases()
	g.writeConversionFunctions()
	g.writeHelperFunctions()

	finalBuf := new(bytes.Buffer)
	g.writeHeaderAndPackageToBuffer(finalBuf)
	g.writeImportsToBuffer(finalBuf)
	finalBuf.Write(g.buf.Bytes())

	return format.Source(finalBuf.Bytes())
}

// CustomStubs returns the generated custom conversion stub functions.
func (g *Generator) CustomStubs() []byte {
	if len(g.customStubs) == 0 {
		return nil
	}

	var buf bytes.Buffer
	buf.WriteString("//go:build !abgen_source\n")
	buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// versions: %s\n", "abgen"))
	buf.WriteString(fmt.Sprintf("// source: %s\n\n", g.config.GenerationContext.DirectivePath))
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.getPackageName()))

	g.importMgr.WriteImportsToBuffer(&buf)

	g.writeCustomStubsToBuffer(&buf)

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		slog.Error("Failed to format custom stubs", "error", err)
		return buf.Bytes()
	}
	return formatted
}

func (g *Generator) writeHeaderAndPackageToBuffer(buf *bytes.Buffer) {
	pkgName := g.getPackageName()
	buf.WriteString("//go:build !abgen_source\n")
	buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// versions: %s\n", "abgen"))
	buf.WriteString(fmt.Sprintf("// source: %s\n\n", g.config.GenerationContext.DirectivePath))
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
}

func (g *Generator) writeImportsToBuffer(buf *bytes.Buffer) {
	imports := g.importMgr.GetAllImports()
	if len(imports) == 0 {
		return
	}
	buf.WriteString("import (\n")
	sort.Strings(imports)
	for _, importPath := range imports {
		alias := g.importMgr.GetAlias(importPath)
		buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, importPath))
	}
	buf.WriteString(")\n\n")
}

func (g *Generator) writeAliases() {
	type aliasPair struct {
		aliasName, fqn string
	}
	aliasesToWrite := make([]aliasPair, 0)
	for fqn, alias := range g.aliasMap {
		// 仅当 fqn 存在于 g.requiredAliases 中时，才生成别名声明
		if _, ok := g.requiredAliases[fqn]; !ok {
			continue
		}
		// Skip aliases that are already defined in the config (ExistingAliases)
		if _, exists := g.config.ExistingAliases[alias]; exists {
			continue
		}
		aliasesToWrite = append(aliasesToWrite, aliasPair{alias, fqn})
	}

	// Filter out aliases for types that were not actually resolved (e.g., due to errors)
	validAliases := make([]aliasPair, 0)
	for _, alias := range aliasesToWrite {
		if g.typeInfos[alias.fqn] != nil {
			validAliases = append(validAliases, alias)
		}
	}

	if len(validAliases) == 0 {
		return
	}

	sort.Slice(validAliases, func(i, j int) bool { return validAliases[i].aliasName < validAliases[j].aliasName })

	g.buf.WriteString("// Local type aliases for external types.\n")
	g.buf.WriteString("type (\n")

	for _, item := range validAliases {
		typeInfo := g.typeInfos[item.fqn]
		// 使用 g.namer.GetTypeString 获取原始类型名称
		originalTypeName := g.namer.GetTypeString(typeInfo)
		g.buf.WriteString(fmt.Sprintf("\t%s = %s\n", item.aliasName, originalTypeName))
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) writeConversionFunctions() {
	rules := g.config.ConversionRules
	sort.Slice(rules, func(i, j int) bool { return rules[i].SourceType < rules[j].SourceType })

	for _, rule := range rules {
		sourceInfo := g.typeInfos[rule.SourceType]
		targetInfo := g.typeInfos[rule.TargetType]
		if sourceInfo == nil || targetInfo == nil {
			slog.Warn("Skipping conversion rule due to unresolved type", "sourceType", rule.SourceType, "targetType", rule.TargetType)
			continue
		}
		g.generateConversionFunction(sourceInfo, targetInfo, rule)
	}
}

func (g *Generator) writeHelperFunctions() {
	if len(g.requiredConversionFunctions) == 0 {
		return
	}
	helpers := make([]string, 0, len(g.requiredConversionFunctions))
	for name := range g.requiredConversionFunctions {
		helpers = append(helpers, name)
	}
	sort.Strings(helpers)
	g.buf.WriteString("\n// --- Helper Functions ---\n")
	for _, name := range helpers {
		if body, ok := conversionFunctionBodies[name]; ok {
			g.buf.WriteString(body)
		}
	}
}

func (g *Generator) writeCustomStubsToBuffer(buf *bytes.Buffer) {
	if len(g.customStubs) == 0 {
		return
	}
	buf.WriteString("\n// --- Custom Conversion Stubs ---\n")
	stubNames := make([]string, 0, len(g.customStubs))
	for name := range g.customStubs {
		stubNames = append(stubNames, name)
	}
	sort.Strings(stubNames)

	for _, name := range stubNames {
		buf.WriteString(g.customStubs[name])
		buf.WriteString("\n")
	}
}

func (g *Generator) generateConversionFunction(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule) {
	g.doGenerateConversionFunction(sourceInfo, targetInfo, rule, false)
	if rule.Direction == config.DirectionBoth {
		reverseRule := &config.ConversionRule{
			SourceType: targetInfo.FQN(),
			TargetType: sourceInfo.FQN(),
			Direction:  config.DirectionOneway,
			FieldRules: config.FieldRuleSet{Ignore: make(map[string]struct{}), Remap: make(map[string]string)},
		}
		for from, to := range rule.FieldRules.Remap {
			reverseRule.FieldRules.Remap[to] = from
		}
		g.doGenerateConversionFunction(targetInfo, sourceInfo, reverseRule, true)
	}
}

func (g *Generator) doGenerateConversionFunction(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule, isReverse bool) {
	// Check if both types are structs. If not, we might not want to generate a pointer-based conversion.
	if !g.converter.IsStruct(sourceInfo) || !g.converter.IsStruct(targetInfo) {
		// For non-struct types (like slices), we generate a value-based conversion.
		if g.converter.IsSlice(sourceInfo) && g.converter.IsSlice(targetInfo) {
			funcName := g.namer.GetFunctionName(sourceInfo, targetInfo)
			g.generateSliceToSliceConversion(funcName, sourceInfo, targetInfo)
		}
		// Potentially handle other non-struct, non-slice types here if necessary.
		return
	}

	funcName := g.namer.GetFunctionName(sourceInfo, targetInfo)

	sourceTypeStr := g.namer.GetTypeString(sourceInfo)
	targetTypeStr := g.namer.GetTypeString(targetInfo)

	g.buf.WriteString(fmt.Sprintf("// %s converts %s to %s\n", funcName, sourceTypeStr, targetTypeStr))
	g.buf.WriteString(fmt.Sprintf("func %s(from *%s) *%s {\n", funcName, sourceTypeStr, targetTypeStr))
	g.buf.WriteString("\tif from == nil {\n\t\treturn nil\n\t}\n\n")
	g.generateStructToStructConversion(sourceInfo, targetInfo, rule)
	g.buf.WriteString("}\n\n")
}

func (g *Generator) generateSliceToSliceConversion(funcName string, sourceInfo, targetInfo *model.TypeInfo) {
	sourceElem := g.converter.GetElementType(sourceInfo)
	targetElem := g.converter.GetElementType(targetInfo)

	// For slice conversion functions, the parameter and return type strings should be generated
	// using namer.GetTypeString to ensure correct pointer handling.
	sourceSliceStr := g.namer.GetTypeString(sourceInfo)
	targetSliceStr := g.namer.GetTypeString(targetInfo)

	g.buf.WriteString(fmt.Sprintf("// %s converts %s to %s\n", funcName, sourceSliceStr, targetSliceStr)) // Add comment for helper
	g.buf.WriteString(fmt.Sprintf("func %s(froms %s) %s {\n", funcName, sourceSliceStr, targetSliceStr))
	g.buf.WriteString("\tif froms == nil {\n\t\treturn nil\t}\n")
	g.buf.WriteString(fmt.Sprintf("\ttos := make(%s, len(froms))\n", targetSliceStr))
	g.buf.WriteString("\tfor i, f := range froms {\n")

	// --- CRITICAL CHANGE HERE ---
	// The element conversion logic must fully delegate to getConversionExpression
	// to ensure required functions are correctly marked.
	// We need to create dummy FieldInfo objects for the element types.
	tempSourceField := &model.FieldInfo{Type: sourceElem, Name: "f"}
	tempTargetField := &model.FieldInfo{Type: targetElem}

	// Call getConversionExpression for the element conversion.
	// The 'fromVar' for the element is 'f'.
	// parentSource and parentTarget are passed for potential stub function naming.
	elementConversionExpr := g.getConversionExpression(sourceInfo, tempSourceField, targetInfo, tempTargetField, "f")

	// Now, use the generated elementConversionExpr
	if targetElem.IsUltimatelyStruct() || targetElem.Kind == model.Pointer { // Check if target element is a struct or pointer
		g.buf.WriteString(fmt.Sprintf("\t\ttos[i] = %s\n", elementConversionExpr))
	} else {
		// For non-pointer, non-struct target elements, we need to dereference if the conversion returns a pointer.
		g.buf.WriteString(fmt.Sprintf("\t\tconverted := %s\n", elementConversionExpr))
		g.buf.WriteString("\t\tif converted != nil {\n")
		g.buf.WriteString("\t\t\ttos[i] = *converted\n")
		g.buf.WriteString("\t\t}\n")
	}

	g.buf.WriteString("\t}\n")
	g.buf.WriteString("\treturn tos\n")
	g.buf.WriteString("}\n\n")
}

func (g *Generator) generateStructToStructConversion(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule) {
	g.buf.WriteString("\tto := &" + g.namer.GetTypeString(targetInfo) + "{\n")
	for _, sourceField := range sourceInfo.Fields {
		if _, shouldIgnore := rule.FieldRules.Ignore[sourceField.Name]; shouldIgnore {
			continue
		}
		targetFieldName := sourceField.Name
		if remappedName, shouldRemap := rule.FieldRules.Remap[sourceField.Name]; shouldRemap {
			targetFieldName = remappedName
		}

		var targetField *model.FieldInfo
		// First, try for an exact (case-sensitive) match.
		for _, tf := range targetInfo.Fields {
			if tf.Name == targetFieldName {
				targetField = tf
				break
			}
		}
		// If no exact match, fall back to case-insensitive matching.
		if targetField == nil {
			for _, tf := range targetInfo.Fields {
				if strings.EqualFold(tf.Name, targetFieldName) {
					targetField = tf
					break
				}
			}
		}
		if targetField != nil {
			// Corrected: Pass targetField (which is *model.FieldInfo) to getConversionExpression
			conversionExpr := g.getConversionExpression(sourceInfo, sourceField, targetInfo, targetField, "from")
			g.buf.WriteString(fmt.Sprintf("\t\t%s: %s,\n", targetField.Name, conversionExpr))
		}
	}
	g.buf.WriteString("\t}\n")
	g.buf.WriteString("\treturn to\n")
}

// isNumericPrimitive checks if a given primitive kind is a numeric type.
func isNumericPrimitive(kind string) bool {
	switch kind {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
		"float32", "float64",
		"complex64", "complex128":
		return true
	default:
		return false
	}
}

// canDirectlyConvertPrimitives checks if two primitive types can be directly converted in Go.
// This is a simplified check and might need to be more comprehensive for all Go rules.
func canDirectlyConvertPrimitives(sourceKind, targetKind string) bool {
	// Identical types can always be converted (no-op)
	if sourceKind == targetKind {
		return true
	}

	// Numeric types can generally be converted to other numeric types
	if isNumericPrimitive(sourceKind) && isNumericPrimitive(targetKind) {
		return true
	}

	// string and []byte, []rune can be converted
	if (sourceKind == "string" && (targetKind == "[]byte" || targetKind == "[]rune")) ||
		((sourceKind == "[]byte" || sourceKind == "[]rune") && targetKind == "string") {
		return true
	}

	// bool, string, and other non-numeric primitives usually cannot be directly converted to each other
	// unless they are identical.
	return false
}

// generatePrimitiveConversionStub generates a stub function for primitive type conversion.
func generatePrimitiveConversionStub(funcName, sourceTypeName, targetTypeName string) string {
	return fmt.Sprintf(`
// %s converts a %s to a %s.
// TODO: Implement the conversion logic for %s to %s.
func %s(from %s) %s {
	// Example: return %s(from) if direct conversion is possible and desired,
	// or implement custom logic.
	panic("not implemented") // TODO: Implement me
}
`, funcName, sourceTypeName, targetTypeName, sourceTypeName, targetTypeName, funcName, sourceTypeName, targetTypeName, targetTypeName)
}

func (g *Generator) getConversionExpression(
	parentSource *model.TypeInfo, sourceField *model.FieldInfo,
	parentTarget *model.TypeInfo, targetField *model.FieldInfo, // Corrected: targetField is now *model.FieldInfo
	fromVar string,
) string { // Removed topLevelNeedsDisambiguation
	sourceType := sourceField.Type
	targetType := targetField.Type // Corrected: targetField is *model.FieldInfo, so targetField.Type is *model.TypeInfo
	sourceFieldExpr := fmt.Sprintf("%s.%s", fromVar, sourceField.Name)

	// Prioritize slice conversion logic
	if sourceType.Kind == model.Slice && targetType.Kind == model.Slice {
		sourceElem := g.converter.GetElementType(sourceType)
		targetElem := g.converter.GetElementType(targetType)

		if sourceElem != nil && targetElem != nil {
			// Only proceed if the element types are different, otherwise direct assignment is fine.
			if sourceElem.UniqueKey() != targetElem.UniqueKey() {
				// Get the name of the dedicated slice conversion helper function
				sliceConverterFuncName := g.namer.GetFunctionName(sourceElem, targetElem) // Pass element types for function name

				// Add the slice conversion function to requiredConversionFunctions
				g.requiredConversionFunctions[sliceConverterFuncName] = true

				// Return the call to the dedicated helper function
				return fmt.Sprintf("%s(%s)", sliceConverterFuncName, sourceFieldExpr)
			}
		}
	}

	sourceKey := sourceType.UniqueKey()
	targetKey := targetType.UniqueKey()

	if sourceKey == targetKey {
		return sourceFieldExpr
	}

	// Check in the unified conversionFunctions map
	conversionKey := sourceKey + "->" + targetKey
	if funcName, ok := conversionFunctions[conversionKey]; ok {
		g.requiredConversionFunctions[funcName] = true
		if strings.Contains(funcName, "Time") {
			g.importMgr.Add("time")
		}
		if strings.Contains(funcName, "UUID") {
			g.importMgr.Add("github.com/google/uuid")
		}
		return fmt.Sprintf("%s(%s)", funcName, sourceFieldExpr)
	}

	// Check for custom function rules from config
	customFuncKey := sourceKey + "->" + targetKey
	if customFuncName, ok := g.config.CustomFunctionRules[customFuncKey]; ok {
		g.requiredConversionFunctions[customFuncName] = true // Mark custom function as required
		return fmt.Sprintf("%s(%s)", customFuncName, sourceFieldExpr)
	}

	// Handle underlying types for named types that are not primitive
	if sourceType.Underlying != nil && targetType.Underlying != nil && sourceType.Underlying.UniqueKey() == targetType.Underlying.UniqueKey() {
		return fmt.Sprintf("%s(%s)", g.namer.GetTypeString(targetType), sourceFieldExpr)
	}
	if sourceType.Underlying != nil && sourceType.Underlying.UniqueKey() == targetKey {
		return fmt.Sprintf("%s(%s)", g.namer.GetTypeString(targetType), sourceFieldExpr)
	}
	if targetType.Underlying != nil && targetType.Underlying.UniqueKey() == sourceKey {
		return fmt.Sprintf("%s(%s)", g.namer.GetTypeString(targetType), sourceFieldExpr)
	}

	// Handle numeric primitive conversions (e.g., int to int32)
	if sourceType.Kind == model.Primitive && targetType.Kind == model.Primitive &&
		isNumericPrimitive(sourceType.Name) && isNumericPrimitive(targetType.Name) {
		return fmt.Sprintf("%s(%s)", g.namer.GetTypeString(targetType), sourceFieldExpr)
	}

	if sourceType.Kind == model.Primitive && targetType.Kind == model.Primitive {
		if canDirectlyConvertPrimitives(sourceType.Name, targetType.Name) {
			return fmt.Sprintf("%s(%s)", g.namer.GetTypeString(targetType), sourceFieldExpr)
		} else {
			// Corrected: Pass targetField (which is *model.FieldInfo) to GetPrimitiveConversionStubName
			stubFuncName := g.namer.GetPrimitiveConversionStubName(parentSource, sourceField, parentTarget, targetField)
			if _, exists := g.customStubs[stubFuncName]; !exists {
				g.customStubs[stubFuncName] = generatePrimitiveConversionStub(
					stubFuncName,
					g.namer.GetTypeString(sourceType),
					g.namer.GetTypeString(targetType),
				)
			}
			g.requiredConversionFunctions[stubFuncName] = true // Mark stub function as required
			return fmt.Sprintf("%s(%s)", stubFuncName, sourceFieldExpr)
		}
	}

	// Fallback to generating/using a dedicated conversion function for complex types (structs, etc.)
	funcName := g.namer.GetFunctionName(sourceType, targetType)
	g.requiredConversionFunctions[funcName] = true // Mark generated function as required
	return fmt.Sprintf("%s(%s)", funcName, sourceFieldExpr)
}

// populateAliases populates the aliasMap with generated aliases for source and target types.
func (g *Generator) populateAliases() {
	// visited := make(map[string]struct{}) // 不再需要visited，因为不再递归
	for _, rule := range g.config.ConversionRules {
		sourceInfo := g.typeInfos[rule.SourceType]
		targetInfo := g.typeInfos[rule.TargetType]
		if sourceInfo == nil || targetInfo == nil {
			continue
		}

		// 为源类型生成别名并存储
		sourceAlias := g.namer.GetAlias(sourceInfo, true)
		g.aliasMap[sourceInfo.UniqueKey()] = sourceAlias
		g.requiredAliases[sourceInfo.UniqueKey()] = struct{}{} // 标记为需要生成别名声明

		// 为目标类型生成别名并存储
		targetAlias := g.namer.GetAlias(targetInfo, false)
		g.aliasMap[targetInfo.UniqueKey()] = targetAlias
		g.requiredAliases[targetInfo.UniqueKey()] = struct{}{} // 标记为需要生成别名声明

		// Add imports for source and target types
		if sourceInfo.ImportPath != "" && !g.isCurrentPackage(sourceInfo.ImportPath) {
			g.importMgr.Add(sourceInfo.ImportPath)
		}
		if targetInfo.ImportPath != "" && !g.isCurrentPackage(targetInfo.ImportPath) {
			g.importMgr.Add(targetInfo.ImportPath)
		}
	}
}

// getTypeString 获取一个 TypeInfo 在生成的 Go 代码中作为类型声明的字符串表示。
// isSourceContext 指示当前类型是否处于源类型上下文中。
// useDefaultDisambiguationSuffixContext 指示当前上下文是否需要默认歧义后缀。
// ignoreAliasMap 为 true 时，将忽略 g.aliasMap 中的别名，直接构建原始类型字符串。
// 此方法已废弃，请直接使用 g.namer.GetTypeString()
// func (g *Generator) getTypeString(info *model.TypeInfo, isSourceContext bool, useDefaultDisambiguationSuffixContext bool, ignoreAliasMap bool) string {
// 	if info == nil {
// 		return "interface{}"
// 	}

// 	key := info.UniqueKey()
// 	// 1. 如果不忽略别名，优先使用 g.aliasMap 中的已计算别名
// 	if !ignoreAliasMap {
// 		if alias, ok := g.aliasMap[key]; ok {
// 			return alias
// 		}
// 		// 2. 检查配置中是否存在现有别名
// 		if alias, ok := g.config.ExistingAliases[key]; ok {
// 			return alias
// 		}
// 	}

// 	// 3. 如果 g.aliasMap 中没有，且不忽略别名，则动态构建字符串，并按需收集别名
// 	// 只有命名类型或复合类型才需要生成别名声明
// 	if !ignoreAliasMap && (info.IsNamedType() || info.Kind == model.Slice || info.Kind == model.Map || info.Kind == model.Array || info.Kind == model.Pointer) {
// 		// 按需生成别名
// 		generatedAlias := g.namer.GetAlias(info, isSourceContext)
// 		g.aliasMap[key] = generatedAlias
// 		g.requiredAliases[key] = struct{}{} // 标记为需要生成别名声明

// 		// Add import if it's an external package.
// 		if info.ImportPath != "" && !g.isCurrentPackage(info.ImportPath) {
// 			g.importMgr.Add(info.ImportPath)
// 		}
// 		return generatedAlias
// 	}

// 	// 4. 对于原始类型，直接返回其名称
// 	if info.Kind == model.Primitive {
// 		return info.Name
// 	}

// 	// 5. 对于其他未处理的类型，构建其原始的 Go 类型字符串
// 	// DELEGATE TO NAMER.GETTYPESTRING FOR ACCURATE CONSTRUCTION
// 	return g.namer.GetTypeString(info) // <--- CHANGE IS HERE
// }

func (g *Generator) discoverImplicitConversionRules() {
	typesByPackage := make(map[string][]*model.TypeInfo)
	for _, info := range g.typeInfos {
		if info.IsNamedType() {
			typesByPackage[info.ImportPath] = append(typesByPackage[info.ImportPath], info)
		}
	}

	var initialRules []*config.ConversionRule

	for _, pair := range g.config.PackagePairs {
		sourceTypes := typesByPackage[pair.SourcePath]
		targetTypes := typesByPackage[pair.TargetPath]

		targetMap := make(map[string]*model.TypeInfo)
		for _, tt := range targetTypes {
			targetMap[tt.Name] = tt
		}

		for _, sourceType := range sourceTypes {
			if targetType, ok := targetMap[sourceType.Name]; ok {
				rule := &config.ConversionRule{
					SourceType: sourceType.UniqueKey(),
					TargetType: targetType.UniqueKey(),
					Direction:  config.DirectionBoth,
					FieldRules: config.FieldRuleSet{Ignore: make(map[string]struct{}), Remap: make(map[string]string)},
				}
				initialRules = append(initialRules, rule)
			}
		}
	}

	g.config.ConversionRules = append(g.config.ConversionRules, initialRules...)

	// Now, generate rules for slice types based on the initial named type rules
	for _, rule := range initialRules {
		sourceInfo := g.typeInfos[rule.SourceType]
		targetInfo := g.typeInfos[rule.TargetType]

		sourceSliceType := &model.TypeInfo{
			Kind:       model.Slice,
			Underlying: sourceInfo,
		}
		targetSliceType := &model.TypeInfo{
			Kind:       model.Slice,
			Underlying: targetInfo,
		}
		g.typeInfos[sourceSliceType.UniqueKey()] = sourceSliceType
		g.typeInfos[targetSliceType.UniqueKey()] = targetSliceType

		sliceRule := &config.ConversionRule{
			SourceType: sourceSliceType.UniqueKey(),
			TargetType: targetSliceType.UniqueKey(),
			Direction:  config.DirectionBoth,
		}

		// 检查是否已经存在与 sourceSliceType 或 targetSliceType 相关的规则
		// 避免生成重复或冲突的隐式切片规则
		foundExistingSliceRule := false
		for _, existingRule := range g.config.ConversionRules {
			if (existingRule.SourceType == sliceRule.SourceType && existingRule.TargetType == sliceRule.TargetType) ||
				(existingRule.SourceType == sliceRule.TargetType && existingRule.TargetType == sliceRule.SourceType && existingRule.Direction == config.DirectionBoth) {
				foundExistingSliceRule = true
				break
			}
		}

		if !foundExistingSliceRule {
			g.config.ConversionRules = append(g.config.ConversionRules, sliceRule)
		}
	}

	sort.Slice(g.config.ConversionRules, func(i, j int) bool {
		if g.config.ConversionRules[i].SourceType != g.config.ConversionRules[j].SourceType {
			return g.config.ConversionRules[i].SourceType < g.config.ConversionRules[j].SourceType
		}
		return g.config.ConversionRules[i].TargetType < g.config.ConversionRules[j].TargetType
	})
}

func (g *Generator) getPackageName() string {
	if g.config.GenerationContext.PackageName != "" {
		return g.config.GenerationContext.PackageName
	}
	return "generated"
}

func (g *Generator) isCurrentPackage(importPath string) bool {
	return importPath == g.config.GenerationContext.PackagePath
}
