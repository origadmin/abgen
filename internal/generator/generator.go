package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"log/slog"
	"sort"
	"strings"

	"github.com/origadmin/abgen/internal/config"
	"github.com/origadmin/abgen/internal/model"
)

var simpleConverters = map[string]string{
	// Removed all entries from simpleConverters.
}

var conversionFunctions = map[string]string{ // Renamed from helperBasedConverters
	"string->time.Time": "ConvertStringToTime",
	"string->uuid.UUID": "ConvertStringToUUID",
	"time.Time->string": "ConvertTimeToString",
	"uuid.UUID->string": "ConvertUUIDToString",
}

var conversionFunctionBodies = map[string]string{ // Renamed from helperFunctionBodies
	"ConvertStringToTime": `
func ConvertStringToTime(s string) time.Time {
	t, _ := time.Parse(time.RFC3339, s)
	return t
}
`,
	"ConvertStringToUUID": `
func ConvertStringToUUID(s string) uuid.UUID {
	u, _ := uuid.Parse(s)
	return u
}
`,
	"ConvertTimeToString": `
func ConvertTimeToString(t time.Time) string {
	return t.Format(time.RFC3339)
}
`,
	"ConvertUUIDToString": `
func ConvertUUIDToString(u uuid.UUID) string {
	return u.String()
}
`,
}

type Generator struct {
	config                      *config.Config
	buf                         bytes.Buffer
	importMgr                   *ImportManager
	converter                   *TypeConverter
	namer                       *Namer
	aliasMap                    map[string]string
	requiredConversionFunctions map[string]bool // Renamed from requiredHelpers
	typeInfos                   map[string]*model.TypeInfo
	customStubs                 map[string]string
	involvedPackages            map[string]struct{}
}

func NewGenerator(config *config.Config) *Generator {
	g := &Generator{
		config:                      config,
		importMgr:                   NewImportManager(),
		aliasMap:                    make(map[string]string),
		requiredConversionFunctions: make(map[string]bool), // Initialize
		customStubs:                 make(map[string]string),
		involvedPackages:            make(map[string]struct{}),
	}
	g.converter = NewTypeConverter() // Initialize converter before passing to Namer
	g.namer = NewNamer(config, g.aliasMap) // Pass converter to Namer
	return g
}

func (g *Generator) Generate(typeInfos map[string]*model.TypeInfo) ([]byte, error) {
	g.typeInfos = typeInfos
	slog.Debug("Generating code", "type_count", len(g.typeInfos), "initial_rules", len(g.config.ConversionRules))

	// Populate the set of involved packages early on.
	for _, pkgPath := range g.config.RequiredPackages() {
		g.involvedPackages[pkgPath] = struct{}{}
	}

	// If no explicit conversion rules are defined, discover them from package pairs.
	// This is the crucial step to enable `pair:packages` to work.
	if len(g.config.ConversionRules) == 0 {
		g.discoverImplicitConversionRules()
		slog.Debug("Implicit rule discovery finished", "discovered_rules", len(g.config.ConversionRules))
	}

	g.populateAliases()

	var bodyBuf bytes.Buffer
	g.buf = bodyBuf

	g.writeAliases()
	g.writeConversionFunctions()
	g.writeHelperFunctions()

	finalBuf := new(bytes.Buffer)
	g.writeHeaderAndPackageToBuffer(finalBuf)
	g.writeImportsToBuffer(finalBuf)
	finalBuf.Write(g.buf.Bytes())

	return format.Source(finalBuf.Bytes())
}

// CustomStubs returns the generated custom conversion stub functions.
func (g *Generator) CustomStubs() []byte {
	if len(g.customStubs) == 0 {
		return nil
	}

	var buf bytes.Buffer
	buf.WriteString("//go:build !abgen_source\n")
	buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// versions: %s\n", "abgen"))
	buf.WriteString(fmt.Sprintf("// source: %s\n\n", g.config.GenerationContext.DirectivePath))
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.getPackageName()))

	g.importMgr.WriteImportsToBuffer(&buf)

	g.writeCustomStubsToBuffer(&buf)

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		slog.Error("Failed to format custom stubs", "error", err)
		return buf.Bytes()
	}
	return formatted
}

func (g *Generator) writeHeaderAndPackageToBuffer(buf *bytes.Buffer) {
	pkgName := g.getPackageName()
	buf.WriteString("//go:build !abgen_source\n")
	buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// versions: %s\n", "abgen"))
	buf.WriteString(fmt.Sprintf("// source: %s\n\n", g.config.GenerationContext.DirectivePath))
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
}

func (g *Generator) writeImportsToBuffer(buf *bytes.Buffer) {
	imports := g.importMgr.GetAllImports()
	if len(imports) == 0 {
		return
	}
	buf.WriteString("import (\n")
	sort.Strings(imports)
	for _, importPath := range imports {
		alias := g.importMgr.GetAlias(importPath)
		buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, importPath))
	}
	buf.WriteString(")\n\n")
}

func (g *Generator) writeAliases() {
	type aliasPair struct {
		aliasName, fqn string
	}
	aliasesToWrite := make([]aliasPair, 0)
	for fqn, alias := range g.aliasMap {
		if _, exists := g.config.ExistingAliases[alias]; exists {
			continue
		}
		aliasesToWrite = append(aliasesToWrite, aliasPair{alias, fqn})
	}

	validAliases := make([]aliasPair, 0)
	for _, alias := range aliasesToWrite {
		if g.typeInfos[alias.fqn] != nil {
			validAliases = append(validAliases, alias)
		}
	}

	if len(validAliases) == 0 {
		return
	}

	sort.Slice(validAliases, func(i, j int) bool { return validAliases[i].aliasName < validAliases[j].aliasName })

	g.buf.WriteString("// Local type aliases for external types.\n")
	g.buf.WriteString("type (\n")

	for _, item := range validAliases {
		typeInfo := g.typeInfos[item.fqn]
		var originalTypeName string
		if typeInfo.IsNamedType() {
			pkgAlias := g.importMgr.GetAlias(typeInfo.ImportPath)
			originalTypeName = fmt.Sprintf("%s.%s", pkgAlias, typeInfo.Name)
		} else {
			// For composite types (like slices), construct the original type string directly
			// to avoid recursive alias definitions (e.g., ItemsSource = ItemsSource).
			if typeInfo.Kind == model.Slice {
				// Construct as []pkg.Type or []AliasType
				originalTypeName = "[]" + g.getTypeString(typeInfo.Underlying)
			} else if typeInfo.Kind == model.Array {
				originalTypeName = fmt.Sprintf("[%d]%s", typeInfo.ArrayLen, g.getTypeString(typeInfo.Underlying))
			} else if typeInfo.Kind == model.Pointer {
				originalTypeName = "*" + g.getTypeString(typeInfo.Underlying)
			} else if typeInfo.Kind == model.Map {
				keyStr := g.getTypeString(typeInfo.KeyType)
				valStr := g.getTypeString(typeInfo.Underlying)
				originalTypeName = fmt.Sprintf("map[%s]%s", keyStr, valStr)
			} else {
				// Fallback for other composite types if needed, or if getTypeString is intended to handle them
				originalTypeName = g.getTypeString(typeInfo)
			}
		}
		g.buf.WriteString(fmt.Sprintf("\t%s = %s\n", item.aliasName, originalTypeName))
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) writeConversionFunctions() {
	rules := g.config.ConversionRules
	sort.Slice(rules, func(i, j int) bool { return rules[i].SourceType < rules[j].SourceType })

	for _, rule := range rules {
		sourceInfo := g.typeInfos[rule.SourceType]
		targetInfo := g.typeInfos[rule.TargetType]
		if sourceInfo == nil || targetInfo == nil {
			continue
		}
		g.generateConversionFunction(sourceInfo, targetInfo, rule)
	}
}

func (g *Generator) writeHelperFunctions() {
	if len(g.requiredConversionFunctions) == 0 {
		return
	}
	helpers := make([]string, 0, len(g.requiredConversionFunctions))
	for name := range g.requiredConversionFunctions {
		helpers = append(helpers, name)
	}
	sort.Strings(helpers)
	g.buf.WriteString("\n// --- Helper Functions ---\n")
	for _, name := range helpers {
		if body, ok := conversionFunctionBodies[name]; ok {
			g.buf.WriteString(body)
		}
	}
}

func (g *Generator) writeCustomStubsToBuffer(buf *bytes.Buffer) {
	if len(g.customStubs) == 0 {
		return
	}
	buf.WriteString("\n// --- Custom Conversion Stubs ---\n")
	stubNames := make([]string, 0, len(g.customStubs))
	for name := range g.customStubs {
		stubNames = append(stubNames, name)
	}
	sort.Strings(stubNames)

	for _, name := range stubNames {
		buf.WriteString(g.customStubs[name])
		buf.WriteString("\n")
	}
}

func (g *Generator) generateConversionFunction(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule) {
	g.doGenerateConversionFunction(sourceInfo, targetInfo, rule, false)
	if rule.Direction == config.DirectionBoth {
		reverseRule := &config.ConversionRule{
			SourceType: targetInfo.FQN(),
			TargetType: sourceInfo.FQN(),
			Direction:  config.DirectionOneway,
			FieldRules: config.FieldRuleSet{Ignore: make(map[string]struct{}), Remap: make(map[string]string)},
		}
		for from, to := range rule.FieldRules.Remap {
			reverseRule.FieldRules.Remap[to] = from
		}
		g.doGenerateConversionFunction(targetInfo, sourceInfo, reverseRule, true)
	}
}

func (g *Generator) doGenerateConversionFunction(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule, isReverse bool) {
	// Check if both types are structs. If not, we might not want to generate a pointer-based conversion.
	if !g.converter.IsStruct(sourceInfo) || !g.converter.IsStruct(targetInfo) {
		// For non-struct types (like slices), we generate a value-based conversion.
		if g.converter.IsSlice(sourceInfo) && g.converter.IsSlice(targetInfo) {
			funcName := g.namer.GetFunctionName(sourceInfo, targetInfo)
			g.generateSliceToSliceConversion(funcName, sourceInfo, targetInfo)
		}
		// Potentially handle other non-struct, non-slice types here if necessary.
		return
	}

	funcName := g.namer.GetFunctionName(sourceInfo, targetInfo)
	sourceTypeStr := g.getTypeString(sourceInfo)
	targetTypeStr := g.getTypeString(targetInfo)

	g.buf.WriteString(fmt.Sprintf("// %s converts %s to %s\n", funcName, sourceTypeStr, targetTypeStr))
	g.buf.WriteString(fmt.Sprintf("func %s(from *%s) *%s {\n", funcName, sourceTypeStr, targetTypeStr))
	g.buf.WriteString("\tif from == nil {\n\t\treturn nil\n\t}\n\n")
	g.generateStructToStructConversion(sourceInfo, targetInfo, rule)
	g.buf.WriteString("}\n\n")
}

func (g *Generator) generateSliceToSliceConversion(funcName string, sourceInfo, targetInfo *model.TypeInfo) {
	sourceElem := g.converter.GetElementType(sourceInfo)
	targetElem := g.converter.GetElementType(targetInfo)
	sourceSliceStr := g.getTypeString(sourceInfo)
	targetSliceStr := g.getTypeString(targetInfo)

	g.buf.WriteString(fmt.Sprintf("// %s converts %s to %s\n", funcName, sourceSliceStr, targetSliceStr)) // Add comment for helper
	g.buf.WriteString(fmt.Sprintf("func %s(froms %s) %s {\n", funcName, sourceSliceStr, targetSliceStr))
	g.buf.WriteString("\tif froms == nil {\n\t\treturn nil\t}\n")
	g.buf.WriteString(fmt.Sprintf("\ttos := make(%s, len(froms))\n", targetSliceStr))
	g.buf.WriteString("\tfor i, f := range froms {\n")

	elementConverterFunc := g.namer.GetFunctionName(sourceElem, targetElem)

	sourceIsPointer := sourceElem.Kind == model.Pointer
	targetIsPointer := targetElem.Kind == model.Pointer

	var callExpr string
	if sourceIsPointer {
		callExpr = fmt.Sprintf("%s(f)", elementConverterFunc)
	} else {
		// If the source slice contains values, we need to pass the address to the converter
		callExpr = fmt.Sprintf("%s(&f)", elementConverterFunc)
	}

	if targetIsPointer {
		g.buf.WriteString(fmt.Sprintf("\t\ttos[i] = %s\n", callExpr))
	} else {
		g.buf.WriteString(fmt.Sprintf("converted := %s\n", callExpr))
		g.buf.WriteString("if converted != nil {\n")
		g.buf.WriteString("tos[i] = *converted\n")
		g.buf.WriteString("}\n")
	}

	g.buf.WriteString("\t}\n")
	g.buf.WriteString("\treturn tos\n")
	g.buf.WriteString("}\n\n")
}

func (g *Generator) generateStructToStructConversion(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule) {
	g.buf.WriteString("\tto := &" + g.getTypeString(targetInfo) + "{\n")
	for _, sourceField := range sourceInfo.Fields {
		if _, shouldIgnore := rule.FieldRules.Ignore[sourceField.Name]; shouldIgnore {
			continue
		}
		targetFieldName := sourceField.Name
		if remappedName, shouldRemap := rule.FieldRules.Remap[sourceField.Name]; shouldRemap {
			targetFieldName = remappedName
		}

		var targetField *model.FieldInfo
		// First, try for an exact (case-sensitive) match.
		for _, tf := range targetInfo.Fields {
			if tf.Name == targetFieldName {
				targetField = tf
				break
			}
		}
		// If no exact match, fall back to case-insensitive matching.
		if targetField == nil {
			for _, tf := range targetInfo.Fields {
				if strings.EqualFold(tf.Name, targetFieldName) {
					targetField = tf
					break
				}
			}
		}
		if targetField != nil {
			// Corrected: Pass targetField (which is *model.FieldInfo) to getConversionExpression
			conversionExpr := g.getConversionExpression(sourceInfo, sourceField, targetInfo, targetField, "from")
			g.buf.WriteString(fmt.Sprintf("\t\t%s: %s,\n", targetField.Name, conversionExpr))
		}
	}
	g.buf.WriteString("\t}\n")
	g.buf.WriteString("\treturn to\n")
}

// isNumericPrimitive checks if a given primitive kind is a numeric type.
func isNumericPrimitive(kind string) bool {
	switch kind {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
		"float32", "float64",
		"complex64", "complex128":
		return true
	default:
		return false
	}
}

// canDirectlyConvertPrimitives checks if two primitive types can be directly converted in Go.
// This is a simplified check and might need to be more comprehensive for all Go rules.
func canDirectlyConvertPrimitives(sourceKind, targetKind string) bool {
	// Identical types can always be converted (no-op)
	if sourceKind == targetKind {
		return true
	}

	// Numeric types can generally be converted to other numeric types
	if isNumericPrimitive(sourceKind) && isNumericPrimitive(targetKind) {
		return true
	}

	// string and []byte, []rune can be converted
	if (sourceKind == "string" && (targetKind == "[]byte" || targetKind == "[]rune")) ||
		((sourceKind == "[]byte" || sourceKind == "[]rune") && targetKind == "string") {
		return true
	}

	// bool, string, and other non-numeric primitives usually cannot be directly converted to each other
	// unless they are identical.
	return false
}

// generatePrimitiveConversionStub generates a stub function for primitive type conversion.
func generatePrimitiveConversionStub(funcName, sourceTypeName, targetTypeName string) string {
	return fmt.Sprintf(`
// %s converts a %s to a %s.
// TODO: Implement the conversion logic for %s to %s.
func %s(from %s) %s {
	// Example: return %s(from) if direct conversion is possible and desired,
	// or implement custom logic.
	panic("not implemented") // TODO: Implement me
}
`, funcName, sourceTypeName, targetTypeName, sourceTypeName, targetTypeName, funcName, sourceTypeName, targetTypeName, targetTypeName)
}

func (g *Generator) getConversionExpression(
	parentSource *model.TypeInfo, sourceField *model.FieldInfo,
	parentTarget *model.TypeInfo, targetField *model.FieldInfo, // Corrected: targetField is now *model.FieldInfo
	fromVar string,
) string {
	sourceType := sourceField.Type
	targetType := targetField.Type // Corrected: targetField is *model.FieldInfo, so targetField.Type is *model.TypeInfo
	sourceFieldExpr := fmt.Sprintf("%s.%s", fromVar, sourceField.Name)

	// Prioritize slice conversion logic
	if sourceType.Kind == model.Slice && targetType.Kind == model.Slice {
		sourceElem := g.converter.GetElementType(sourceType)
		targetElem := g.converter.GetElementType(targetType)

		if sourceElem != nil && targetElem != nil {
			// Only proceed if the element types are different, otherwise direct assignment is fine.
			if sourceElem.UniqueKey() != targetElem.UniqueKey() {
				// Get the name of the dedicated slice conversion helper function
				sliceConverterFuncName := g.namer.GetFunctionName(sourceType, targetType)

				// Return the call to the dedicated helper function
				return fmt.Sprintf("%s(%s)", sliceConverterFuncName, sourceFieldExpr)
			}
		}
	}

	sourceKey := sourceType.UniqueKey()
	targetKey := targetType.UniqueKey()

	if sourceKey == targetKey {
		return sourceFieldExpr
	}

	// Check in the unified conversionFunctions map
	conversionKey := sourceKey + "->" + targetKey
	if funcName, ok := conversionFunctions[conversionKey]; ok {
		g.requiredConversionFunctions[funcName] = true
		if strings.Contains(funcName, "Time") {
			g.importMgr.Add("time")
		}
		if strings.Contains(funcName, "UUID") {
			g.importMgr.Add("github.com/google/uuid")
		}
		return fmt.Sprintf("%s(%s)", funcName, sourceFieldExpr)
	}

	// Check for custom function rules from config
	customFuncKey := sourceKey + "->" + targetKey
	if customFuncName, ok := g.config.CustomFunctionRules[customFuncKey]; ok {
		return fmt.Sprintf("%s(%s)", customFuncName, sourceFieldExpr)
	}

	// Handle underlying types for named types that are not primitive
	if sourceType.Underlying != nil && targetType.Underlying != nil && sourceType.Underlying.UniqueKey() == targetType.Underlying.UniqueKey() {
		return fmt.Sprintf("%s(%s)", g.getTypeString(targetType), sourceFieldExpr)
	}
	if sourceType.Underlying != nil && sourceType.Underlying.UniqueKey() == targetKey {
		return fmt.Sprintf("%s(%s)", g.getTypeString(targetType), sourceFieldExpr)
	}
	if targetType.Underlying != nil && targetType.Underlying.UniqueKey() == sourceKey {
		return fmt.Sprintf("%s(%s)", g.getTypeString(targetType), sourceFieldExpr)
	}

	// Handle numeric primitive conversions (e.g., int to int32)
	if sourceType.Kind == model.Primitive && targetType.Kind == model.Primitive &&
		isNumericPrimitive(sourceType.Name) && isNumericPrimitive(targetType.Name) {
		return fmt.Sprintf("%s(%s)", g.getTypeString(targetType), sourceFieldExpr)
	}

	if sourceType.Kind == model.Primitive && targetType.Kind == model.Primitive {
		if canDirectlyConvertPrimitives(sourceType.Name, targetType.Name) {
			return fmt.Sprintf("%s(%s)", g.getTypeString(targetType), sourceFieldExpr)
		} else {
			// Corrected: Pass targetField (which is *model.FieldInfo) to GetPrimitiveConversionStubName
			stubFuncName := g.namer.GetPrimitiveConversionStubName(parentSource, sourceField, parentTarget, targetField)
			if _, exists := g.customStubs[stubFuncName]; !exists {
				g.customStubs[stubFuncName] = generatePrimitiveConversionStub(
					stubFuncName,
					g.getTypeString(sourceType),
					g.getTypeString(targetType),
				)
			}
			return fmt.Sprintf("%s(%s)", stubFuncName, sourceFieldExpr)
		}
	}

	// Fallback to generating/using a dedicated conversion function for complex types (structs, etc.)
	funcName := g.namer.GetFunctionName(sourceType, targetType)
	return fmt.Sprintf("%s(%s)", funcName, sourceFieldExpr)
}

func (g *Generator) populateAliases() {
	visited := make(map[string]struct{})
	for _, rule := range g.config.ConversionRules {
		sourceInfo := g.typeInfos[rule.SourceType]
		targetInfo := g.typeInfos[rule.TargetType]
		if sourceInfo == nil || targetInfo == nil {
			continue
		}

		hasSourceSpecificRule := g.config.NamingRules.SourcePrefix != "" || g.config.NamingRules.SourceSuffix != ""
		hasTargetSpecificRule := g.config.NamingRules.TargetPrefix != "" || g.config.NamingRules.TargetSuffix != ""
		
		// Disambiguate if source and target have same name but different packages
		// and either source or target (or both) lack specific naming rules
		sourceNeedsDisambiguation := sourceInfo.Name == targetInfo.Name && sourceInfo.ImportPath != targetInfo.ImportPath && !hasSourceSpecificRule
		targetNeedsDisambiguation := sourceInfo.Name == targetInfo.Name && sourceInfo.ImportPath != targetInfo.ImportPath && !hasTargetSpecificRule

		g.createAliasesRecursively(sourceInfo, true, sourceNeedsDisambiguation, visited)
		g.createAliasesRecursively(targetInfo, false, targetNeedsDisambiguation, visited)
	}
}

func (g *Generator) createAliasesRecursively(info *model.TypeInfo, isSource, disambiguate bool, visited map[string]struct{}) {
	if info == nil || (info.UniqueKey() == "" && info.Kind != model.Primitive) {
		return
	}

	key := info.UniqueKey()
	if _, ok := visited[key]; ok {
		return
	}
	visited[key] = struct{}{}

	// Always create an alias for a named type, regardless of whether it's from an involved package.
	// This is crucial for types that are fields within other types.
	if info.IsNamedType() {
		alias := g.namer.GetAlias(info, isSource, disambiguate)
		if _, exists := g.config.ExistingAliases[alias]; !exists {
			if _, exists := g.aliasMap[key]; !exists {
				g.aliasMap[key] = alias
			}
		} else {
			g.aliasMap[key] = alias
		}
	} else if info.Kind == model.Slice { // Handle non-named slice types
		// Ensure the underlying element type has an alias first
		if info.Underlying != nil {
			g.createAliasesRecursively(info.Underlying, isSource, disambiguate, visited)
		}
		
		// Create an alias for the slice type itself, based on its element's alias
		if info.Underlying != nil && info.Underlying.UniqueKey() != "" {
			// Get the base name of the element type, pluralize it, and then apply naming rules.
			elemBaseName := info.Underlying.Name
			pluralElemBaseName := elemBaseName + "s" // Simple pluralization for now.

			sliceAlias := g.namer.getFinalAlias(pluralElemBaseName, isSource, disambiguate)
			sliceKey := "[]" + info.Underlying.UniqueKey()
			if _, exists := g.aliasMap[sliceKey]; !exists {
				g.aliasMap[sliceKey] = sliceAlias
			}
		}
	}


	if info.ImportPath != "" && !g.isCurrentPackage(info.ImportPath) {
		g.importMgr.Add(info.ImportPath)
	}

	// Recursively process fields for structs and element types for slices/arrays/maps.
	switch info.Kind {
	case model.Struct:
		for _, field := range info.Fields {
			g.createAliasesRecursively(field.Type, isSource, disambiguate, visited)
		}
	case model.Slice, model.Array, model.Pointer:
		if info.Underlying != nil {
			g.createAliasesRecursively(info.Underlying, isSource, disambiguate, visited)
		}
	case model.Map:
		if info.KeyType != nil {
			g.createAliasesRecursively(info.KeyType, isSource, disambiguate, visited)
		}
		if info.Underlying != nil { // Corrected: Use info.Underlying for map value type
			g.createAliasesRecursively(info.Underlying, isSource, disambiguate, visited)
		}
	}
}

func (g *Generator) getAliasedName(info *model.TypeInfo) string {
	key := info.UniqueKey()
	if alias, ok := g.aliasMap[key]; ok {
		return alias
	}
	if alias, ok := g.config.ExistingAliases[key]; ok {
		return alias
	}
	return info.Name // Fallback to base name if no alias found
}


func (g *Generator) getTypeString(info *model.TypeInfo) string {
	if info == nil {
		return "interface{}"
	}

	// For non-named types, construct the type string recursively.
	if !info.IsNamedType() {
		switch info.Kind {
		case model.Primitive:
			return info.Name
		case model.Slice:
			// If an alias exists for the slice type itself, use it.
			sliceKey := "[]" + info.Underlying.UniqueKey()
			if alias, ok := g.aliasMap[sliceKey]; ok {
				return alias
			}
			return "[]" + g.getTypeString(info.Underlying)
		case model.Pointer:
			return "*" + g.getTypeString(info.Underlying)
		case model.Map:
			keyStr := g.getTypeString(info.KeyType)
			valStr := g.getTypeString(info.Underlying) // Corrected: Use info.Underlying for map value type
			return fmt.Sprintf("map[%s]%s", keyStr, valStr)
		case model.Array:
			return fmt.Sprintf("[%d]%s", info.ArrayLen, g.getTypeString(info.Underlying))
		default:
			return "interface{}" // Fallback
		}
	}

	// For named types, use the alias if it exists.
	key := info.UniqueKey()
	if alias, ok := g.aliasMap[key]; ok {
		return alias
	}
	if alias, ok := g.config.ExistingAliases[key]; ok {
		return alias
	}

	// Fallback for named types that might not have an alias (should be rare).
	if info.ImportPath != "" && !g.isCurrentPackage(info.ImportPath) {
		pkgAlias := g.importMgr.GetAlias(info.ImportPath)
		return fmt.Sprintf("%s.%s", pkgAlias, info.Name)
	}
	return info.Name
}

func (g *Generator) discoverImplicitConversionRules() {
	typesByPackage := make(map[string][]*model.TypeInfo)
	for _, info := range g.typeInfos {
		// We only consider named types for implicit rule discovery.
		if info.IsNamedType() {
			typesByPackage[info.ImportPath] = append(typesByPackage[info.ImportPath], info)
		}
	}

	// Store initially discovered rules to then process slice types
	var initialRules []*config.ConversionRule

	for _, pair := range g.config.PackagePairs {
		sourceTypes := typesByPackage[pair.SourcePath]
		targetTypes := typesByPackage[pair.TargetPath]

		// Create a map for quick lookups of target types by name.
		targetMap := make(map[string]*model.TypeInfo)
		for _, tt := range targetTypes {
			targetMap[tt.Name] = tt
		}

		for _, sourceType := range sourceTypes {
			// If a matching type name exists in the target package, create a rule.
			if targetType, ok := targetMap[sourceType.Name]; ok {
				rule := &config.ConversionRule{
					SourceType: sourceType.UniqueKey(), // Use UniqueKey() for named types too for consistency
					TargetType: targetType.UniqueKey(), // Use UniqueKey()
					Direction:  config.DirectionBoth,    // Default to 'both' for implicit rules.
					FieldRules: config.FieldRuleSet{Ignore: make(map[string]struct{}), Remap: make(map[string]string)},
				}
				initialRules = append(initialRules, rule)
			}
		}
	}

	g.config.ConversionRules = append(g.config.ConversionRules, initialRules...)

	// Now, generate rules for slice types based on the initial named type rules
	for _, rule := range initialRules {
		sourceInfo := g.typeInfos[rule.SourceType]
		targetInfo := g.typeInfos[rule.TargetType]

		// Create slice TypeInfo for source and target
		sourceSliceType := &model.TypeInfo{
			Kind:       model.Slice,
			Underlying: sourceInfo,
		}
		targetSliceType := &model.TypeInfo{
			Kind:       model.Slice,
			Underlying: targetInfo,
		}
		// Add these newly created TypeInfo objects to g.typeInfos so they can be looked up later.
		g.typeInfos[sourceSliceType.UniqueKey()] = sourceSliceType
		g.typeInfos[targetSliceType.UniqueKey()] = targetSliceType

		// Add rule for slice conversion
		sliceRule := &config.ConversionRule{
			SourceType: sourceSliceType.UniqueKey(),
			TargetType: targetSliceType.UniqueKey(),
			Direction:  config.DirectionBoth, // Always generate both directions for slice helpers
		}
		g.config.ConversionRules = append(g.config.ConversionRules, sliceRule)
	}

	// Sort the rules for consistent generation order.
	sort.Slice(g.config.ConversionRules, func(i, j int) bool {
		if g.config.ConversionRules[i].SourceType != g.config.ConversionRules[j].SourceType {
			return g.config.ConversionRules[i].SourceType < g.config.ConversionRules[j].SourceType
		}
		return g.config.ConversionRules[i].TargetType < g.config.ConversionRules[j].TargetType
	})
}

func (g *Generator) getPackageName() string {
	if g.config.GenerationContext.PackageName != "" {
		return g.config.GenerationContext.PackageName
	}
	return "generated"
}

func (g *Generator) isCurrentPackage(importPath string) bool {
	return importPath == g.config.GenerationContext.PackagePath
}
