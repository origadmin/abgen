// Package generator is responsible for generating the Go source code based on the
// analysis results from the AST walker.
package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/origadmin/abgen/internal/ast"
	"github.com/origadmin/abgen/internal/types"
)

// Generator holds the state for code generation.
type Generator struct {
	walker  *ast.PackageWalker
	config  *types.ConversionConfig
	buf     bytes.Buffer
	imports *ImportManager
}

// NewGenerator creates a new Generator instance.
func NewGenerator(walker *ast.PackageWalker) *Generator {
	return &Generator{
		walker: walker,
	}
}

// Generate produces the Go source code for the conversions.
func (g *Generator) Generate() ([]byte, error) {
	g.config = g.walker.Config()
	g.imports = NewImportManager()

	pkgName := path.Base(g.config.ContextPackagePath)
	g.buf.WriteString("package " + pkgName + "\n\n")
	g.buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n\n")

	g.collectImports()
	g.writeImports()
	g.generateConversionFunctions()

	return format.Source(g.buf.Bytes())
}

// collectImports gathers all necessary imports from the configuration.
func (g *Generator) collectImports() {
	for _, pair := range g.config.Pairs {
		g.addImportFromFQN(pair.Source.Type)
		g.addImportFromFQN(pair.Target.Type)
	}
}

// addImportFromFQN adds an import path from a fully qualified type name.
func (g *Generator) addImportFromFQN(fqn string) {
	if fqn == "" || !strings.Contains(fqn, ".") {
		return
	}
	pkgPath, _ := splitFQN(fqn)
	if pkgPath != "" && pkgPath != g.config.ContextPackagePath {
		g.imports.Add(pkgPath)
	}
}

// writeImports writes the import block to the buffer.
func (g *Generator) writeImports() {
	if len(g.imports.imports) == 0 {
		return
	}
	paths := make([]string, 0, len(g.imports.imports))
	for p := range g.imports.imports {
		paths = append(paths, p)
	}
	sort.Strings(paths)

	g.buf.WriteString("import (\n")
	for _, p := range paths {
		alias := g.imports.imports[p]
		g.buf.WriteString("\t" + alias + " " + strconv.Quote(p) + "\n")
	}
	g.buf.WriteString(")\n\n")
}

// generateConversionFunctions iterates through pairs and generates functions.
func (g *Generator) generateConversionFunctions() {
	// Sort pairs for consistent output
	sort.Slice(g.config.Pairs, func(i, j int) bool {
		return g.config.Pairs[i].Source.Type < g.config.Pairs[j].Source.Type
	})

	for _, pair := range g.config.Pairs {
		g.generateSingleConversionFunc(pair)
		if g.config.Direction == "both" {
			// Create a reversed pair for the other direction
			reversePair := &types.TypePair{
				Source: pair.Target,
				Target: pair.Source,
			}
			g.generateSingleConversionFunc(reversePair)
		}
	}
}

// generateSingleConversionFunc generates one conversion function for a given pair.
func (g *Generator) generateSingleConversionFunc(pair *types.TypePair) {
	sourceInfo, err := g.walker.Resolve(pair.Source.Type)
	if err != nil {
		g.buf.WriteString(fmt.Sprintf("// ERROR: could not resolve source type %q: %v\n", pair.Source.Type, err))
		return
	}
	targetInfo, err := g.walker.Resolve(pair.Target.Type)
	if err != nil {
		g.buf.WriteString(fmt.Sprintf("// ERROR: could not resolve target type %q: %v\n", pair.Target.Type, err))
		return
	}

	sourceNamePart := g.getFuncNamePart(sourceInfo, g.config.Source.Prefix, g.config.Source.Suffix)
	targetNamePart := g.getFuncNamePart(targetInfo, g.config.Target.Prefix, g.config.Target.Suffix)

	funcName := "Convert" + sourceNamePart + "To" + targetNamePart
	sourceTypeStr := g.getTypeName(sourceInfo)
	targetTypeStr := g.getTypeName(targetInfo)

	g.buf.WriteString(fmt.Sprintf("// %s converts a *%s to a *%s.\n", funcName, sourceTypeStr, targetTypeStr))
	g.buf.WriteString(fmt.Sprintf("func %s(from *%s) *%s {\n", funcName, sourceTypeStr, targetTypeStr))
	g.buf.WriteString("\tif from == nil {\n\t\treturn nil\n\t}\n")
	g.buf.WriteString(fmt.Sprintf("\tto := &%s{}\n\n", targetTypeStr))

	for _, field := range sourceInfo.Fields {
		g.handleFieldAssignment(field, sourceInfo, targetInfo)
	}

	g.buf.WriteString("\n\treturn to\n}\n\n")
}

// handleFieldAssignment generates the assignment logic for a single field.
func (g *Generator) handleFieldAssignment(sourceField types.StructField, sourceInfo, targetInfo *types.TypeInfo) {
	fqnField := sourceInfo.ImportPath + "." + sourceInfo.Name + "#" + sourceField.Name
	if g.config.IgnoreFields[fqnField] {
		g.buf.WriteString(fmt.Sprintf("\t// Ignored field: %s\n", sourceField.Name))
		return
	}

	targetFieldName := sourceField.Name
	if remap, ok := g.config.RemapFields[fqnField]; ok {
		targetFieldName = remap
	}

	targetField, ok := findField(targetInfo.Fields, targetFieldName)
	if !ok {
		g.buf.WriteString(fmt.Sprintf("\t// Field %s not found in target type %s\n", targetFieldName, targetInfo.Name))
		return
	}

	sourceFieldType, _ := g.walker.Resolve(sourceField.Type)
	targetFieldType, _ := g.walker.Resolve(targetField.Type)

	assignmentStr := ""
	if sourceField.Type == targetField.Type {
		assignmentStr = fmt.Sprintf("from.%s", sourceField.Name)
	} else if customFunc := g.findCustomRule(sourceFieldType, targetFieldType); customFunc != "" {
		assignmentStr = fmt.Sprintf("%s(from.%s)", customFunc, sourceField.Name)
	} else {
		// Fallback to a standard conversion function name
		convFuncName := "Convert" + g.getFuncNamePart(sourceFieldType, "", "") + "To" + g.getFuncNamePart(targetFieldType, "", "")
		assignmentStr = fmt.Sprintf("%s(from.%s)", convFuncName, sourceField.Name)
	}

	g.buf.WriteString(fmt.Sprintf("\tto.%s = %s\n", targetFieldName, assignmentStr))
}

// getFuncNamePart computes a part of the function name based on global naming rules.
func (g *Generator) getFuncNamePart(typeInfo *types.TypeInfo, prefix, suffix string) string {
	if typeInfo.LocalAlias != "" {
		return typeInfo.LocalAlias
	}
	if prefix != "" || suffix != "" {
		return prefix + typeInfo.Name + suffix
	}
	return typeInfo.Name
}

// getTypeName returns the string representation of a type, including its package alias.
func (g *Generator) getTypeName(typeInfo *types.TypeInfo) string {
	if typeInfo.LocalAlias != "" {
		return typeInfo.LocalAlias
	}
	if typeInfo.ImportPath != "" && typeInfo.ImportPath != "builtin" && typeInfo.ImportPath != g.config.ContextPackagePath {
		pkgAlias := g.imports.Add(typeInfo.ImportPath)
		return pkgAlias + "." + typeInfo.Name
	}
	return typeInfo.Name
}

func (g *Generator) findCustomRule(sourceType, targetType *types.TypeInfo) string {
	for _, rule := range g.config.CustomRules {
		if rule.SourceTypeName == sourceType.Name && rule.TargetTypeName == targetType.Name {
			return rule.ConvertFunc
		}
	}
	return ""
}

// --- Utility Functions ---

func findField(fields []types.StructField, name string) (types.StructField, bool) {
	for _, field := range fields {
		if field.Name == name {
			return field, true
		}
	}
	return types.StructField{}, false
}

func splitFQN(fqn string) (pkgPath, typeName string) {
	lastDot := strings.LastIndex(fqn, ".")
	if lastDot == -1 {
		return "", fqn
	}
	return fqn[:lastDot], fqn[lastDot+1:]
}

// ImportManager handles import path collection and alias generation.
type ImportManager struct {
	imports map[string]string // Maps import path to alias
}

// NewImportManager creates a new ImportManager.
func NewImportManager() *ImportManager {
	return &ImportManager{
		imports: make(map[string]string),
	}
}

// Add adds an import path and returns the alias to be used in the generated code.
func (im *ImportManager) Add(importPath string) string {
	if alias, exists := im.imports[importPath]; exists {
		return alias
	}
	alias := path.Base(importPath)
	originalAlias := alias
	counter := 1
	for {
		isConflict := false
		for _, existingAlias := range im.imports {
			if existingAlias == alias {
				isConflict = true
				alias = originalAlias + strconv.Itoa(counter)
				counter++
				break
			}
		}
		if !isConflict {
			break
		}
	}
	im.imports[importPath] = alias
	return alias
}
