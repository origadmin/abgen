package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"log/slog"
	"sort"
	"strings"

	"github.com/origadmin/abgen/internal/config"
	"github.com/origadmin/abgen/internal/model"
)

// Generator holds the state for code generation.
type Generator struct {
	config    *config.Config
	buf       bytes.Buffer
	importMgr *ImportManager
	converter *TypeConverter
	namer     *Namer
	processed map[string]bool
	aliasMap  map[string]string // Maps FQN to alias
}

// NewGenerator creates a new Generator instance.
func NewGenerator(config *config.Config) *Generator {
		g := &Generator{
			config:    config,
			importMgr: NewImportManager(),
			processed: make(map[string]bool),
			aliasMap:  make(map[string]string),
		}
		g.namer = NewNamer(config, g.aliasMap) // Pass aliasMap to Namer
		g.converter = NewTypeConverter()
		return g
}

// Generate produces the Go source code for the conversions. It takes the pre-analyzed type information.
func (g *Generator) Generate(typeInfos map[string]*model.TypeInfo) ([]byte, error) {
	slog.Debug("Generating code", "type_count", len(typeInfos), "rules", len(g.config.ConversionRules))
	for fqn, info := range typeInfos {
		slog.Debug("Type info received by generator", "fqn", fqn, "name", info.Name, "kind", info.Kind)
	}

	// 1. Discover implicit conversion rules if no explicit rules are defined
	if len(g.config.ConversionRules) == 0 {
		g.discoverImplicitConversionRules(typeInfos)
	}

	// 2. Populate aliases for all referenced types (after all rules are known)
	g.populateAliases(typeInfos)

	// 3. Generate the actual code
	g.buf.Reset()
	g.writeHeaderAndPackage() // Renamed to reflect new order
	g.writeImports()
	g.writeAliases(typeInfos)
	g.writeConversionFunctions(typeInfos)

	// 4. Format and return
	return format.Source(g.buf.Bytes())
}

// CustomStubs generates custom conversion stubs for complex conversions.
func (g *Generator) CustomStubs() []byte {
	var stubBuf bytes.Buffer

	stubBuf.WriteString("package ")
	stubBuf.WriteString(g.getPackageName())
	stubBuf.WriteString("\n\n")
	stubBuf.WriteString("// Code generated by abgen for custom conversion stubs. DO NOT EDIT.\n\n")

	// Format the stub code
	formatted, err := format.Source(stubBuf.Bytes())
	if err != nil {
		slog.Warn("Failed to format custom stubs", "error", err)
		return stubBuf.Bytes()
	}
	return formatted
}

// writeHeaderAndPackage writes the file header comments and the package declaration.
func (g *Generator) writeHeaderAndPackage() {
	pkgName := g.getPackageName()
	// Write comments first
	g.buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	g.buf.WriteString(fmt.Sprintf("// versions: %s\n", config.Application))
	// Use the directive path directly from config, it should already be relative for test cases.
	// Omit timestamp for deterministic golden file comparison.
	g.buf.WriteString(fmt.Sprintf("// source: %s\n\n", g.config.GenerationContext.DirectivePath))
	// Then write package declaration
	g.buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
}

func (g *Generator) writeImports() {
	// The import manager is populated during alias and task discovery.
	imports := g.importMgr.GetAllImports()
	if len(imports) == 0 {
		return
	}
	g.buf.WriteString("import (\n")
	// Sort imports for consistent output
	sortedImports := make([]string, 0, len(imports))
	for _, importPath := range imports {
		sortedImports = append(sortedImports, importPath)
	}
	sort.Strings(sortedImports)

	for _, importPath := range sortedImports {
		alias := g.importMgr.GetAlias(importPath)
		g.buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, importPath))
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) writeAliases(typeInfos map[string]*model.TypeInfo) {
	if len(g.aliasMap) == 0 {
		return
	}
	g.buf.WriteString("// Local type aliases for external types.\n")
	g.buf.WriteString("type (\n")

	// To ensure consistent output, sort the aliases by alias name
	type aliasPair struct {
		aliasName string // The local alias name, e.g., "DepartmentPB"
		typeInfo  *model.TypeInfo
	}
	aliases := make([]aliasPair, 0, len(g.aliasMap))
	for fqn, alias := range g.aliasMap {
		typeInfo, exists := typeInfos[fqn]
		if !exists {
			slog.Warn("Type not found for alias", "fqn", fqn)
			continue
		}
		aliases = append(aliases, aliasPair{
			aliasName: alias,
			typeInfo:  typeInfo,
		})
	}

	sort.Slice(aliases, func(i, j int) bool {
		return aliases[i].aliasName < aliases[j].aliasName
	})

	for _, item := range aliases {
		// The right-hand side of the alias should be the fully qualified original type,
		// using the ImportManager's aliases for its package.
		// We need the package alias + original type name, not the local alias.
		pkgAlias := g.importMgr.GetAlias(item.typeInfo.ImportPath)
		originalTypeName := fmt.Sprintf("%s.%s", pkgAlias, item.typeInfo.Name)
		g.buf.WriteString(fmt.Sprintf("\t%s = %s\n", item.aliasName, originalTypeName))
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) writeConversionFunctions(typeInfos map[string]*model.TypeInfo) {
	// Sort rules to ensure consistent output
	rules := g.config.ConversionRules
	sort.Slice(rules, func(i, j int) bool {
		return rules[i].SourceType < rules[j].SourceType
	})

	for _, rule := range rules {
		sourceInfo, sourceExists := typeInfos[rule.SourceType]
		targetInfo, targetExists := typeInfos[rule.TargetType]

		if !sourceExists {
			slog.Warn("Source type not found", "type", rule.SourceType)
			continue
		}
		if !targetExists {
			slog.Warn("Target type not found", "type", rule.TargetType)
			continue
		}

		// Generate forward conversion
		g.generateConversionFunction(sourceInfo, targetInfo, rule)

		// If direction is both, generate reverse conversion
		if rule.Direction == config.DirectionBoth {
			// For reverse conversion, swap source and target, and reverse remap rules
			reverseRule := &config.ConversionRule{
				SourceType: targetInfo.FQN(),
				TargetType: sourceInfo.FQN(),
				Direction:  config.DirectionOneway, // Reverse is always one-way from its perspective
				FieldRules: config.FieldRuleSet{
					Ignore: make(map[string]struct{}), // Ignore rules don't reverse directly
					Remap:  make(map[string]string),
				},
			}
			// Reverse remap rules: target field name becomes source field name
			for from, to := range rule.FieldRules.Remap {
				reverseRule.FieldRules.Remap[to] = from
			}
			g.generateConversionFunction(targetInfo, sourceInfo, reverseRule)
		}
	}
}

// discoverImplicitConversionRules finds and adds conversion rules based on package pairs
// and type naming conventions (e.g., User -> UserDTO).
func (g *Generator) discoverImplicitConversionRules(typeInfos map[string]*model.TypeInfo) {
	slog.Debug("Discovering implicit conversion rules start", "numTypeInfos", len(typeInfos), "numPackagePairsInConfig", len(g.config.PackagePairs))

	// Group typeInfos by package path
	typesByPackage := make(map[string][]*model.TypeInfo)
	for _, info := range typeInfos {
		if info.IsNamedType() && info.Kind == model.Struct { // Only consider named structs for implicit conversion
			typesByPackage[info.ImportPath] = append(typesByPackage[info.ImportPath], info)
			slog.Debug("Grouped type", "fqn", info.FQN(), "importPath", info.ImportPath, "name", info.Name, "kind", info.Kind)
		}
	}

	for _, pair := range g.config.PackagePairs {
		slog.Debug("Processing package pair", "sourcePath", pair.SourcePath, "targetPath", pair.TargetPath)

		sourceTypes := typesByPackage[pair.SourcePath]
		targetTypes := typesByPackage[pair.TargetPath]

		// Sort sourceTypes for deterministic iteration
		sort.Slice(sourceTypes, func(i, j int) bool {
			return sourceTypes[i].FQN() < sourceTypes[j].FQN()
		})
		// Sort targetTypes for deterministic iteration
		sort.Slice(targetTypes, func(i, j int) bool {
			return targetTypes[i].FQN() < targetTypes[j].FQN()
		})

		slog.Debug("Source types found for package", "path", pair.SourcePath, "count", len(sourceTypes))
		slog.Debug("Target types found for package", "path", pair.TargetPath, "count", len(targetTypes))

		for _, sourceType := range sourceTypes {
			for _, targetType := range targetTypes {
				slog.Debug("Comparing types", "sourceTypeName", sourceType.Name, "targetTypeName", targetType.Name, "sourceFQN", sourceType.FQN(), "targetFQN", targetType.FQN())
				// Implicit matching logic: SourceType.Name == TargetType.Name
				if sourceType.Name == targetType.Name {
					rule := &config.ConversionRule{
						SourceType: sourceType.FQN(),
						TargetType: targetType.FQN(),
						Direction:  config.DirectionBoth, // Default to both for implicit rules
						FieldRules: config.FieldRuleSet{
							Ignore: make(map[string]struct{}),
							Remap:  make(map[string]string),
						},
					}
					g.config.ConversionRules = append(g.config.ConversionRules, rule)
					slog.Debug("Discovered implicit rule", "source", sourceType.FQN(), "target", targetType.FQN(), "currentRulesCount", len(g.config.ConversionRules))
				}
			}
		}
	}
	// Sort the entire ConversionRules slice after all implicit rules have been discovered
	sort.Slice(g.config.ConversionRules, func(i, j int) bool {
		if g.config.ConversionRules[i].SourceType != g.config.ConversionRules[j].SourceType {
			return g.config.ConversionRules[i].SourceType < g.config.ConversionRules[j].SourceType
		}
		return g.config.ConversionRules[i].TargetType < g.config.ConversionRules[j].TargetType
	})
	slog.Debug("Finished discovering implicit conversion rules", "total_rules", len(g.config.ConversionRules))
}

// Helper methods
func (g *Generator) getPackageName() string {
	if g.config.GenerationContext.PackageName != "" {
		return g.config.GenerationContext.PackageName
	}
	return "generated"
}

func (g *Generator) isCurrentPackage(importPath string) bool {
	return importPath == g.config.GenerationContext.PackagePath
}

func (g *Generator) getTypeString(info *model.TypeInfo) string {
	if info == nil {
		return "interface{}"
	}

	// Check if a local alias exists for the FQN, it takes precedence
	if alias, ok := g.aliasMap[info.FQN()]; ok {
		return alias
	}

	// If it's a named type from an external package, use the package alias
	if info.IsNamedType() && info.ImportPath != "" && !g.isCurrentPackage(info.ImportPath) {
		pkgAlias := g.importMgr.GetAlias(info.ImportPath)
		return pkgAlias + "." + info.Name
	}

	// Otherwise, return its simple name (e.g., local type, primitive)
	return info.Name
}

func (g *Generator) generateConversionFunction(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule) {
	funcName := g.namer.GetFunctionName(sourceInfo, targetInfo)

	// Use getTypeString for comments as well
	g.buf.WriteString(fmt.Sprintf("// %s converts %s to %s\n", funcName, g.getTypeString(sourceInfo), g.getTypeString(targetInfo)))
	g.buf.WriteString(fmt.Sprintf("func %s(from *%s) *%s {\n", funcName, g.getTypeString(sourceInfo), g.getTypeString(targetInfo))) // Changed to pointer parameters

	// Add nil check for from
	g.buf.WriteString("\tif from == nil {\n")
	g.buf.WriteString("\t\treturn nil\n")
	g.buf.WriteString("\t}\n\n")

	if g.converter.IsStruct(sourceInfo) && g.converter.IsStruct(targetInfo) {
		g.generateStructToStructConversion(sourceInfo, targetInfo, rule)
	} else if g.converter.IsSlice(sourceInfo) && g.converter.IsSlice(targetInfo) {
		g.generateSliceToSliceConversion(sourceInfo, targetInfo, rule)
	} else {
		// Default simple conversion, this part needs to be reviewed as well for pointer handling
		// For now, it might still return a value type depending on how 'target' is handled internally
		g.buf.WriteString("\t// TODO: Implement proper non-struct/non-slice conversion with pointers\n")
		g.buf.WriteString("\treturn nil // Placeholder for now\n")
	}

	g.buf.WriteString("}\n\n")
}

func (g *Generator) generateStructToStructConversion(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule) {
	g.buf.WriteString("\tto := &" + g.getTypeString(targetInfo) + "{\n") // Initialize as pointer

	// Generate field assignments
	for _, sourceField := range sourceInfo.Fields {
		// Check if field should be ignored
		if _, shouldIgnore := rule.FieldRules.Ignore[sourceField.Name]; shouldIgnore {
			continue
		}

		// Check if field should be remapped
		targetFieldName := sourceField.Name
		if remappedName, shouldRemap := rule.FieldRules.Remap[sourceField.Name]; shouldRemap {
			targetFieldName = remappedName
		}

		// Find corresponding target field
		var targetField *model.FieldInfo
		for _, tf := range targetInfo.Fields {
			// Case-insensitive matching for field names
			if strings.EqualFold(tf.Name, targetFieldName) {
				targetField = tf
				break
			}
		}

		if targetField != nil {
			g.buf.WriteString(fmt.Sprintf("\t\t%s: from.%s,\n", targetField.Name, sourceField.Name)) // Use 'from'
		}
	}

	g.buf.WriteString("\t}\n")
	g.buf.WriteString("\treturn to\n") // Return the pointer
}

func (g *Generator) generateSliceToSliceConversion(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule) {
	sourceElem := sourceInfo.Underlying // Get element type of the slice
	targetElem := targetInfo.Underlying // Get element type of the slice

	if sourceElem != nil && targetElem != nil {
		funcName := g.namer.GetFunctionName(sourceElem, targetElem)
		g.buf.WriteString("\tif from == nil {\n") // Changed to 'from'
		g.buf.WriteString("\t\treturn nil\n")
		g.buf.WriteString("\t}\n")
		g.buf.WriteString(fmt.Sprintf("\tto := make([]*%s, 0, len(*from))\n", g.getTypeString(targetElem))) // Dereference 'from'
		g.buf.WriteString("\tfor _, item := range *from {\n")                                              // Dereference 'from' slice
		g.buf.WriteString("\t\tto = append(to, " + funcName + "(&item))\n")                          // Pass address of item, append pointer
		g.buf.WriteString("\t}\n")
		g.buf.WriteString("\treturn &to\n") // Return pointer to the slice
	} else {
		// Fallback for cases where element types are not clearly struct or primitive
		g.buf.WriteString("\treturn nil\n")
	}
}

// populateAliases populates the aliasMap with all referenced types from conversion rules.
func (g *Generator) populateAliases(typeInfos map[string]*model.TypeInfo) {
	slog.Debug("Populating aliases", "numRules", len(g.config.ConversionRules))

	// First pass: Add all required package imports based on conversion rules
	for _, rule := range g.config.ConversionRules {
		sourceInfo, sourceExists := typeInfos[rule.SourceType]
		targetInfo, targetExists := typeInfos[rule.TargetType]

		if sourceExists && sourceInfo.ImportPath != "" && !g.isCurrentPackage(sourceInfo.ImportPath) {
			g.importMgr.Add(sourceInfo.ImportPath)
		}
		if targetExists && targetInfo.ImportPath != "" && !g.isCurrentPackage(targetInfo.ImportPath) {
			g.importMgr.Add(targetInfo.ImportPath)
		}
	}

	// Second pass: Determine and store aliases for types involved in conversion rules
	// This pass handles disambiguation for types with same names from different packages
	for _, rule := range g.config.ConversionRules {
		sourceInfo := typeInfos[rule.SourceType]
		targetInfo := typeInfos[rule.TargetType]

		// Determine aliases for source and target types
		sourceAlias := sourceInfo.Name
		targetAlias := targetInfo.Name

		// Apply disambiguation if types have the same name but different packages
		if sourceInfo.Name == targetInfo.Name && sourceInfo.ImportPath != targetInfo.ImportPath {
			sourceAlias = sourceInfo.Name + "Source"
			targetAlias = targetInfo.Name + "Target"
		}
		
		// If explicit local alias is defined in config, use it (overrides auto-generated)
		if g.config.LocalAliases[sourceInfo.FQN()] != "" {
			sourceAlias = g.config.LocalAliases[sourceInfo.FQN()]
		}
		if g.config.LocalAliases[targetInfo.FQN()] != "" {
			targetAlias = g.config.LocalAliases[targetInfo.FQN()]
		}

		g.aliasMap[sourceInfo.FQN()] = sourceAlias
		g.aliasMap[targetInfo.FQN()] = targetAlias
	}

	slog.Debug("Final aliasMap state", "size", len(g.aliasMap))
	for fqn, alias := range g.aliasMap {
		slog.Debug("Alias entry", "fqn", fqn, "alias", alias)
	}

	// Add all other referenced types to import manager
	for _, typeInfo := range typeInfos {
		if typeInfo.IsNamedType() && typeInfo.ImportPath != "" && !g.isCurrentPackage(typeInfo.ImportPath) {
			// Only add to import manager if not already aliased and handled
			if _, exists := g.aliasMap[typeInfo.FQN()]; !exists {
				g.importMgr.Add(typeInfo.ImportPath)
			}
		}
	}
}
