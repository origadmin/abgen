// Package generator is responsible for generating the Go source code based on the
// analysis results from the analyzer and configuration from the config package.
package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"go/types" // Import go/types for type checking
	"log/slog"
	"strings"

	"github.com/origadmin/abgen/internal/analyzer"
	"github.com/origadmin/abgen/internal/config"
	"github.com/origadmin/abgen/internal/model"
)

// Generator holds the state for code generation.
type Generator struct {
	walker    *analyzer.PackageWalker
	ruleSet   *config.RuleSet
	buf       bytes.Buffer
	importMgr *ImportManager
	converter *TypeConverter
	namer     *Namer
	tasks     []*model.ConversionTask
	processed map[string]bool
}

// NewGenerator creates a new Generator instance.
func NewGenerator(walker *analyzer.PackageWalker, ruleSet *config.RuleSet) *Generator {
	return &Generator{
		walker:    walker,
		ruleSet:   ruleSet,
		importMgr: NewImportManager(),
		converter: NewTypeConverter(),
		namer:     NewNamer(ruleSet),
		tasks:     make([]*model.ConversionTask, 0),
		processed: make(map[string]bool),
	}
}

// Generate produces the Go source code for the conversions.
func (g *Generator) Generate() ([]byte, error) {
	// Discover tasks before generating code
	if err := g.DiscoverTasks(); err != nil {
		return nil, fmt.Errorf("failed to discover conversion tasks: %w", err)
	}

	// Reset buffer
	g.buf.Reset()

	// Add package declaration
	pkgName := g.getPackageName()
	g.buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
	g.buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n\n")

	// Collect imports
	g.collectImports()

	// Write imports
	g.writeImports()

	// Generate conversion functions
	g.generateConversionFunctions()

	// Format the output
	return format.Source(g.buf.Bytes())
}

// collectImports collects all necessary imports.
func (g *Generator) collectImports() {
	for _, task := range g.tasks {
		g.addImportFromType(task.SourceType)
		g.addImportFromType(task.TargetType)
	}
}

// addImportFromType adds import from a type if needed.
func (g *Generator) addImportFromType(t *model.Type) {
	if t == nil {
		return
	}
	if t.ImportPath != "" && t.ImportPath != "builtin" && !g.isCurrentPackage(t.ImportPath) {
		g.importMgr.Add(t.ImportPath)
	}
}

// writeImports writes the import block.
func (g *Generator) writeImports() {
	imports := g.importMgr.GetAllImports()
	if len(imports) == 0 {
		return
	}

	g.buf.WriteString("import (\n")
	for _, importPath := range imports {
		alias := g.importMgr.GetAlias(importPath)
		g.buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, importPath))
	}
	g.buf.WriteString(")\n\n")
}

// generateConversionFunctions generates all conversion functions.
func (g *Generator) generateConversionFunctions() {
	for _, task := range g.tasks {
		g.generateConversionFunction(task)
	}
}

// generateConversionFunction generates a single conversion function.
func (g *Generator) generateConversionFunction(task *model.ConversionTask) {
	sourceType := task.SourceType
	targetType := task.TargetType

	funcName := g.getFunctionName(sourceType, targetType)
	sourceParam := g.getTypeString(sourceType)
	targetReturn := g.getTypeString(targetType)

	g.buf.WriteString(fmt.Sprintf("// %s converts %s to %s\n", funcName, sourceParam, targetReturn))
	g.buf.WriteString(fmt.Sprintf("func %s(from %s) %s {\n", funcName, sourceParam, targetReturn))

	// Add nil check for pointers
	if sourceType.IsPointer {
		g.buf.WriteString("\tif from == nil {\n\t\treturn nil\n\t}\n")
	}

	// Generate conversion logic based on type kinds
	switch {
	case sourceType.Kind == model.TypeKindStruct && targetType.Kind == model.TypeKindStruct:
		g.generateStructToStructConversion(sourceType, targetType)
	case sourceType.Kind == model.TypeKindSlice && targetType.Kind == model.TypeKindSlice:
		g.generateSliceToSliceConversion(sourceType, targetType)
	default:
		g.generateBasicConversion(sourceType, targetType)
	}

	g.buf.WriteString("}\n\n")
}

// generateStructToStructConversion generates struct-to-struct conversion.
func (g *Generator) generateStructToStructConversion(source, target *model.Type) {
	targetTypeName := g.getTypeName(target)
	g.buf.WriteString(fmt.Sprintf("\tto := &%s{}\n\n", targetTypeName))

	for _, sourceField := range source.Fields {
		targetFieldName := g.getTargetFieldName(sourceField.Name)
		targetField := g.findField(target, targetFieldName)
		if targetField == nil {
			continue // Skip if target field doesn't exist
		}

		// Check if field should be ignored
		if g.shouldIgnoreField(source, sourceField.Name) {
			continue
		}

		// Generate field assignment
		g.generateFieldAssignment(sourceField, targetField)
	}

	g.buf.WriteString("\treturn to\n")
}

// generateSliceToSliceConversion generates slice-to-slice conversion.
func (g *Generator) generateSliceToSliceConversion(source, target *model.Type) {
	targetTypeName := g.getTypeString(target)
	g.buf.WriteString(fmt.Sprintf("\tif from == nil {\n\t\treturn nil\n\t}\n"))
	g.buf.WriteString(fmt.Sprintf("\tto := make(%s, len(from))\n", targetTypeName))
	g.buf.WriteString("\tfor i, item := range from {\n")

	// Generate element conversion
	elemFuncName := g.getFunctionName(source.ElementType, target.ElementType)
	g.buf.WriteString(fmt.Sprintf("\t\tto[i] = %s(item)\n", elemFuncName))

	g.buf.WriteString("\t}\n\treturn to\n")
}

// generateBasicConversion generates basic type conversion.
func (g *Generator) generateBasicConversion(source, target *model.Type) {
	// For basic types, use direct conversion
	if g.canDirectConvert(source, target) {
		g.buf.WriteString(fmt.Sprintf("\treturn %s(from)\n", target.Name))
	} else {
		// For complex types, this would need more sophisticated logic
		g.buf.WriteString(fmt.Sprintf("\t// TODO: Implement conversion from %s to %s\n", source.Name, target.Name))
		g.buf.WriteString("\tpanic(\"conversion not implemented\")\n")
	}
}

// generateFieldAssignment generates assignment for a single field.
func (g *Generator) generateFieldAssignment(sourceField, targetField *model.Field) {
	sourceAccess := fmt.Sprintf("from.%s", sourceField.Name)
	targetAccess := fmt.Sprintf("to.%s", targetField.Name)

	// Check if types are the same
	if g.isSameType(sourceField.Type, targetField.Type) {
		g.buf.WriteString(fmt.Sprintf("\t%s = %s\n", targetAccess, sourceAccess))
		return
	}

	// Need conversion
	convFuncName := g.getFunctionName(sourceField.Type, targetField.Type)
	if convFuncName != "" {
		g.buf.WriteString(fmt.Sprintf("\t%s = %s(%s)\n", targetAccess, convFuncName, sourceAccess))
	} else {
		g.buf.WriteString(fmt.Sprintf("\t// TODO: Convert %s field %s\n", sourceField.Type.Name, sourceField.Name))
		g.buf.WriteString(fmt.Sprintf("\t// %s = %s\n", targetAccess, sourceAccess))
	}
}

// getFunctionName generates the function name for conversion.
func (g *Generator) getFunctionName(source, target *model.Type) string {
	return g.namer.GetFunctionName(source, target)
}

// getTypeString returns the full type string for parameters/returns.
func (g *Generator) getTypeString(t *model.Type) string {
	if t.IsPointer {
		return fmt.Sprintf("*%s", g.getTypeName(t))
	}
	return g.getTypeName(t)
}

// getTypeName returns the type name for use in code.
func (g *Generator) getTypeName(t *model.Type) string {
	if t.ImportPath != "" && !g.isCurrentPackage(t.ImportPath) {
		if alias := g.importMgr.GetAlias(t.ImportPath); alias != "" {
			return fmt.Sprintf("%s.%s", alias, t.Name)
		}
	}
	return t.Name
}

// getSimpleTypeName returns the simple type name without package prefixes.
func (g *Generator) getSimpleTypeName(t *model.Type) string {
	name := t.Name
	if t.IsPointer {
		name = strings.TrimPrefix(name, "*")
	}
	if t.Kind == model.TypeKindSlice {
		name = strings.TrimPrefix(name, "[]")
	}
	return name
}

// getPackageName returns the current package name.
func (g *Generator) getPackageName() string {
	// This should be derived from the context package in the rule set
	// For now, return a default
	return "generated"
}

// isCurrentPackage checks if the import path is the current package.
func (g *Generator) isCurrentPackage(importPath string) bool {
	// TODO: Get this from the rule set context
	return false
}

// getTargetFieldName returns the target field name after applying remap rules.
func (g *Generator) getTargetFieldName(sourceFieldName string) string {
	// TODO: Apply remap rules from rule set
	return sourceFieldName
}

// shouldIgnoreField checks if a field should be ignored.
func (g *Generator) shouldIgnoreField(t *model.Type, fieldName string) bool {
	// TODO: Apply ignore rules from rule set
	return false
}

// findField finds a field in a struct by name.
func (g *Generator) findField(structType *model.Type, fieldName string) *model.Field {
	for _, field := range structType.Fields {
		if strings.EqualFold(field.Name, fieldName) {
			return field
		}
	}
	return nil
}

// isSameType checks if two types are the same.
func (g *Generator) isSameType(a, b *model.Type) bool {
	return a.Name == b.Name && a.ImportPath == b.ImportPath && a.IsPointer == b.IsPointer
}

// canDirectConvert checks if direct conversion is possible.
func (g *Generator) canDirectConvert(source, target *model.Type) bool {
	// TODO: Implement more sophisticated conversion logic
	return source.Name == target.Name
}

// AddTask adds a conversion task to the generator.
func (g *Generator) AddTask(sourceType, targetType *model.Type) {
	task := &model.ConversionTask{
		SourceType: sourceType,
		TargetType: targetType,
		Direction:  model.DirectionTo,
		RuleSet:    g.ruleSet,
	}
	g.tasks = append(g.tasks, task)
}

// DiscoverTasks discovers conversion tasks from analyzer and rule set.
func (g *Generator) DiscoverTasks() error {
	slog.Debug("Discovering conversion tasks...")

	// 1. Get package pairing rules
	packagePairs := g.ruleSet.PackagePairs
	if len(packagePairs) == 0 {
		slog.Warn("No package pairing rules found. No conversion tasks will be generated.")
		return nil
	}

	// 2. Iterate through all loaded packages in the walker
	for _, pkg := range g.walker.GetLoadedPackages() {
		// We only care about packages that are part of a pairing rule (as a source package)
		targetPkgPath, isSourcePkg := packagePairs[pkg.PkgPath]
		if !isSourcePkg {
			continue
		}

		slog.Debug("Processing source package for tasks", "sourcePkg", pkg.PkgPath, "targetPkg", targetPkgPath)

		// Iterate through all named types in the source package
		for _, typeName := range pkg.Types.Scope().Names() {
			obj := pkg.Types.Scope().Lookup(typeName)
			if obj == nil || !obj.Exported() {
				continue // Skip unexported or non-existent objects
			}

			// Only process actual types (not functions, variables, etc.)
			if _, ok := obj.(*types.TypeName); !ok {
				continue
			}

			sourceFQN := pkg.PkgPath + "." + typeName
			sourceTypeInfo, err := g.walker.FindTypeByFQN(sourceFQN)
			if err != nil {
				slog.Error("Failed to find source type info", "fqn", sourceFQN, "error", err)
				continue
			}

			// Convert analyzer.TypeInfo to model.Type
			sourceModelType := g.convertAnalyzerTypeToModel(sourceTypeInfo)
			if sourceModelType == nil {
				slog.Error("Failed to convert source analyzer.TypeInfo to model.Type", "fqn", sourceFQN)
				continue
			}

			// Predict target type name based on naming rules
			predictedTargetTypeName := g.applyNamingRules(sourceTypeInfo.Name)
			targetFQN := targetPkgPath + "." + predictedTargetTypeName

			targetTypeInfo, err := g.walker.FindTypeByFQN(targetFQN)
			if err != nil {
				slog.Debug("Target type not found for source type", "sourceFQN", sourceFQN, "targetFQN", targetFQN, "error", err)
				continue // Target type might not exist, skip this conversion task
			}

			targetModelType := g.convertAnalyzerTypeToModel(targetTypeInfo)
			if targetModelType == nil {
				slog.Error("Failed to convert target analyzer.TypeInfo to model.Type", "fqn", targetFQN)
				continue
			}

			// Add conversion task (Source -> Target)
			g.AddTask(sourceModelType, targetModelType)
			slog.Debug("Added conversion task", "source", sourceFQN, "target", targetFQN)

			// TODO: Add reverse conversion task (Target -> Source) based on rules if needed
		}
	}

	slog.Debug("Finished discovering conversion tasks", "totalTasks", len(g.tasks))
	return nil
}

// applyNamingRules applies naming rules to get target type name.
func (g *Generator) applyNamingRules(sourceName string) string {
	// Apply prefix and suffix rules
	result := sourceName
	if g.ruleSet.NamingRules.SourcePrefix != "" && strings.HasPrefix(result, g.ruleSet.NamingRules.SourcePrefix) {
		result = strings.TrimPrefix(result, g.ruleSet.NamingRules.SourcePrefix)
	}
	if g.ruleSet.NamingRules.SourceSuffix != "" && strings.HasSuffix(result, g.ruleSet.NamingRules.SourceSuffix) {
		result = strings.TrimSuffix(result, g.ruleSet.NamingRules.SourceSuffix)
	}
	if g.ruleSet.NamingRules.TargetPrefix != "" {
		result = g.ruleSet.NamingRules.TargetPrefix + result
	}
	if g.ruleSet.NamingRules.TargetSuffix != "" {
		result = result + g.ruleSet.NamingRules.TargetSuffix
	}
	return result
}

// convertAnalyzerTypeToModel converts analyzer.TypeInfo to model.Type.
func (g *Generator) convertAnalyzerTypeToModel(info *analyzer.TypeInfo) *model.Type {
	return g.converter.ConvertToModel(info)
}
