// Package generator is responsible for generating the Go source code based on the
// analysis results from the AST walker.
package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/origadmin/abgen/internal/ast"
	"github.com/origadmin/abgen/internal/types"
)

// ImportManager handles import path collection and alias generation.
type ImportManager struct {
	imports map[string]string // Maps import path to alias
}

// NewImportManager creates a new ImportManager.
func NewImportManager() *ImportManager {
	return &ImportManager{
		imports: make(map[string]string),
	}
}

// Add adds an import path and returns the alias to be used in the generated code.
func (im *ImportManager) Add(importPath string) string {
	if alias, exists := im.imports[importPath]; exists {
		return alias
	}
	// Generate a unique alias to avoid conflicts
	alias := path.Base(importPath)
	originalAlias := alias
	counter := 1
	for {
		isConflict := false
		for _, existingAlias := range im.imports {
			if existingAlias == alias {
				isConflict = true
				alias = originalAlias + strconv.Itoa(counter)
				counter++
				break
			}
		}
		if !isConflict {
			break
		}
	}
	im.imports[importPath] = alias // Map path to its unique alias
	return alias
}

// Generator holds the state required for code generation.
type Generator struct {
	walker  *ast.PackageWalker
	buf     bytes.Buffer
	imports *ImportManager
}

// NewGenerator creates a new Generator instance.
func NewGenerator(walker *ast.PackageWalker) *Generator {
	return &Generator{
		walker: walker,
	}
}

// Generate produces the Go source code for the conversions.
func (g *Generator) Generate() ([]byte, error) {
	g.imports = NewImportManager()

	// Use the package name from the walker's current package context.
	// This ensures the generated file has the correct package declaration.
	pkgName := g.walker.GetCurrentPackage().Name
	g.buf.WriteString("package " + pkgName + "\n\n")

	// --- Generate Header ---
	g.buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	g.buf.WriteString("// versions:\n")
	g.buf.WriteString("// 	abgen v0.0.1\n\n") // Placeholder version

	// --- Collect Imports ---
	// Iterate through all configs to collect all necessary imports.
	for _, cfg := range g.walker.GetRules() { // Use getter
		// Imports for Source Type
		if cfg.Source != nil && cfg.Source.Type != "" && cfg.Source.LocalAlias == "" {
			sourceTypeInfo, err := g.walker.Resolve(cfg.Source.Type)
			if err == nil && sourceTypeInfo.ImportPath != "" && sourceTypeInfo.ImportPath != "builtin" && sourceTypeInfo.ImportPath != g.walker.GetCurrentPackage().PkgPath {
				g.imports.Add(sourceTypeInfo.ImportPath)
			}
		}
		// Imports for Target Type
		if cfg.Target != nil && cfg.Target.Type != "" && cfg.Target.LocalAlias == "" {
			targetTypeInfo, err := g.walker.Resolve(cfg.Target.Type)
			if err == nil && targetTypeInfo.ImportPath != "" && targetTypeInfo.ImportPath != "builtin" && targetTypeInfo.ImportPath != g.walker.GetCurrentPackage().PkgPath {
				g.imports.Add(targetTypeInfo.ImportPath)
			}
		}
	}

	// --- Generate Import Block ---
	if len(g.imports.imports) > 0 {
		// Sort imports for consistent output
		paths := make([]string, 0, len(g.imports.imports))
		for p := range g.imports.imports {
			paths = append(paths, p)
		}
		sort.Strings(paths)

		g.buf.WriteString("import (\n")
		for _, path := range paths {
			alias := g.imports.imports[path]
			g.buf.WriteString("\t" + alias + " " + strconv.Quote(path) + "\n")
		}
		g.buf.WriteString(")\n\n")
	}

	// --- Generate Conversion Functions ---
	g.generateConversionFunctions()

	return format.Source(g.buf.Bytes())
}

func (g *Generator) findFieldCaseInsensitive(fields []types.StructField, name string) (types.StructField, bool) {
	for _, field := range fields {
		if strings.EqualFold(field.Name, name) {
			return field, true
		}
	}
	return types.StructField{}, false
}

// generateSingleConversionFunc generates a single struct-to-struct conversion function.
func (g *Generator) generateSingleConversionFunc(cfg *types.ConversionConfig, fromType, toType types.TypeInfo) { // Signature changed
	// Determine the actual type string for generated code, following the priority:
	// 1. LocalAlias (if present)
	// 2. Derived Alias (Prefix + Name + Suffix, if configured)
	// 3. Package Alias + Type Name (default fallback)

	// For Source Type
	var finalFromTypeStr string
	if fromType.LocalAlias != "" { // Priority 1: Local Alias from TypeInfo
		finalFromTypeStr = fromType.LocalAlias
	} else if cfg.SourcePrefix != "" || cfg.SourceSuffix != "" { // Priority 2: Derived Alias (from ConversionConfig)
		derivedName := cfg.SourcePrefix + fromType.Name + cfg.SourceSuffix
		if derivedName != fromType.Name { // If any prefix/suffix was applied
			finalFromTypeStr = derivedName
		} else { // Fallback if derived name is same as base name
			fromAlias := g.imports.Add(fromType.ImportPath)
			finalFromTypeStr = fromAlias + "." + fromType.Name
		}
	} else { // Priority 3: Package Alias + Type Name
		fromAlias := g.imports.Add(fromType.ImportPath)
		finalFromTypeStr = fromAlias + "." + fromType.Name
	}

	// For Target Type
	var finalToTypeStr string
	if toType.LocalAlias != "" { // Priority 1: Local Alias from TypeInfo
		finalToTypeStr = toType.LocalAlias
	} else if cfg.TargetPrefix != "" || cfg.TargetSuffix != "" { // Priority 2: Derived Alias (from ConversionConfig)
		derivedName := cfg.TargetPrefix + toType.Name + cfg.TargetSuffix
		if derivedName != toType.Name { // If any prefix/suffix was applied
			finalToTypeStr = derivedName
		} else { // Fallback if derived name is same as base name
			toAlias := g.imports.Add(toType.ImportPath)
			finalToTypeStr = toAlias + "." + toType.Name
		}
	} else { // Priority 3: Package Alias + Type Name
		toAlias := g.imports.Add(toType.ImportPath)
		finalToTypeStr = toAlias + "." + toType.Name
	}

	// Function Name Generation: This should also follow the alias pattern
	// For function name, let's use the final display strings, but without package prefixes.
	// This ensures consistency if the types themselves are local aliases or derived.
	fromFuncNamePart := strings.TrimPrefix(finalFromTypeStr, strings.Split(finalFromTypeStr, ".")[0]+".")
	toFuncNamePart := strings.TrimPrefix(finalToTypeStr, strings.Split(finalToTypeStr, ".")[0]+".")

	funcName := "Convert" + fromFuncNamePart + "To" + toFuncNamePart

	g.buf.WriteString(fmt.Sprintf("// %s converts a *%s to a *%s.\n", funcName, finalFromTypeStr, finalToTypeStr))
	g.buf.WriteString(fmt.Sprintf("func %s(from *%s) *%s {\n", funcName, finalFromTypeStr, finalToTypeStr))
	g.buf.WriteString("\tif from == nil {\n")
	g.buf.WriteString("\t\treturn nil\n")
	g.buf.WriteString("\t}\n")
	g.buf.WriteString(fmt.Sprintf("\tto := &%s{}\n\n", finalToTypeStr))

	// Create a map for target fields for case-insensitive lookup
	targetFieldMap := make(map[string]types.StructField)
	for _, f := range toType.Fields {
		targetFieldMap[strings.ToLower(f.Name)] = f
	}

	for _, sourceField := range fromType.Fields {
		sourceFieldFQN := fromType.ImportPath + "." + fromType.Name + "#" + sourceField.Name

		// Check if field is ignored by global/package rules, then by specific conversion rules
		if _, ignored := cfg.IgnoreFields[sourceFieldFQN]; ignored {
			continue
		}
        if _, ignored := cfg.IgnoreTypes[fromType.ImportPath+"."+fromType.Name]; ignored { // Check type-level ignore from cfg
            continue
        }


		var finalTargetFieldName string
		var matchedTargetField types.StructField
		var targetFieldFound bool

		if remapName, ok := cfg.RemapFields[sourceFieldFQN]; ok {
			// Explicit remap takes precedence
			finalTargetFieldName = remapName
			matchedTargetField, targetFieldFound = g.findFieldCaseInsensitive(toType.Fields, finalTargetFieldName)
		} else {
			// Automatic case-insensitive matching
			matchedTargetField, targetFieldFound = g.findFieldCaseInsensitive(toType.Fields, sourceField.Name)
			if targetFieldFound {
				finalTargetFieldName = matchedTargetField.Name // Use the actual casing from the target struct
			}
		}

		if !targetFieldFound {
			continue
		}

		// A simple and effective compatibility check for now.
		sourceTypeClean := strings.TrimPrefix(sourceField.Type, "builtin.")
		targetTypeClean := strings.TrimPrefix(matchedTargetField.Type, "builtin.")
		if sourceTypeClean == targetTypeClean {
			g.buf.WriteString(fmt.Sprintf("\tto.%s = from.%s\n", finalTargetFieldName, sourceField.Name))
		}
	}

	g.buf.WriteString("\n\treturn to\n")
	g.buf.WriteString("}\n")
}

func (g *Generator) generateConversionFunctions() {
	// Collect all configs first and then sort.
	var allConfigs []*types.ConversionConfig
	for _, cfg := range g.walker.GetRules() { // Use getter
		allConfigs = append(allConfigs, cfg)
	}

	// Sort by source type and then target type for stable output.
	sort.Slice(allConfigs, func(i, j int) bool {
		if allConfigs[i].Source.Type != allConfigs[j].Source.Type {
			return allConfigs[i].Source.Type < allConfigs[j].Source.Type
		}
		return allConfigs[i].Target.Type < allConfigs[j].Target.Type
	})

	for _, cfg := range allConfigs {
		sourceTypeInfo, err := g.walker.Resolve(cfg.Source.Type)
		if err != nil {
			g.buf.WriteString(fmt.Sprintf("// ERROR: could not resolve source type %q: %v\n", cfg.Source.Type, err))
			continue
		}
		targetTypeInfo, err := g.walker.Resolve(cfg.Target.Type)
		if err != nil {
			g.buf.WriteString(fmt.Sprintf("// ERROR: could not resolve target type %q: %v\n", cfg.Target.Type, err))
			continue
		}

		// Generate forward conversion
		g.generateSingleConversionFunc(cfg, sourceTypeInfo, targetTypeInfo) // Pass cfg directly
		g.buf.WriteString("\n") // Add a newline between functions

		// Generate reverse conversion if direction is "both"
		if cfg.Direction == "both" {
			// For reverse, we need to create a reversed config view
			reverseCfg := cfg.Clone() // Clone current config
			// Swap source and target endpoints
			reverseCfg.Source = cfg.Target.Clone()
			reverseCfg.Target = cfg.Source.Clone()
			// Swap prefixes/suffixes for the reverse conversion as well
			reverseCfg.SourcePrefix = cfg.TargetPrefix
			reverseCfg.SourceSuffix = cfg.TargetSuffix
			reverseCfg.TargetPrefix = cfg.SourcePrefix
			reverseCfg.TargetSuffix = cfg.SourceSuffix
			reverseCfg.Direction = "to" // The reverse is always a simple "to"

			g.generateSingleConversionFunc(
				reverseCfg,     // Pass the reversed config
				targetTypeInfo, // Pass target as new source
				sourceTypeInfo, // Pass source as new target
			)
			g.buf.WriteString("\n") // Add a newline between functions
		}
	}
}
