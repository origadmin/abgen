// Package generator is responsible for generating the Go source code based on the
// analysis results from the AST walker.
package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"log/slog"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/origadmin/abgen/internal/ast"
	"github.com/origadmin/abgen/internal/types"
)

// conversionTask represents a single function generation task.
type conversionTask struct {
	Source *types.TypeInfo
	Target *types.TypeInfo
}

// Generator holds the state for code generation.
type Generator struct {
	walker           *ast.PackageWalker
	config           *types.ConversionConfig
	buf              bytes.Buffer
	customBuf        bytes.Buffer // Buffer for custom.gen.go
	imports          *ImportManager
	generatedAliases map[string]string
	tasks            []conversionTask
	generatedTasks   map[string]bool
	customTasks      map[string]conversionTask // Tasks for custom.gen.go
	localTypeAliases map[string]string         // Added: Map of local type alias names to their FQNs
}

// NewGenerator creates a new Generator instance.
func NewGenerator(walker *ast.PackageWalker) *Generator {
	return &Generator{
		walker:           walker,
		localTypeAliases: walker.GetLocalTypeNameToFQN(), // Added: Initialize localTypeAliases
	}
}

// Generate produces the Go source code for the conversions.
func (g *Generator) Generate() ([]byte, error) {
	g.config = g.walker.Config()
	g.imports = NewImportManager()
	g.generatedAliases = make(map[string]string)
	g.tasks = make([]conversionTask, 0)
	g.generatedTasks = make(map[string]bool)
	g.customTasks = make(map[string]conversionTask)

	// 1. Discover all tasks (dry run)
	g.addInitialTasks()
	g.discoverAllTasks()

	// 2. Write package and header
	pkgName := path.Base(g.config.ContextPackagePath)
	g.buf.WriteString("package " + pkgName + "\n\n")
	g.buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n\n")

	// 3. Write imports based on all discovered tasks
	g.collectAndWriteImports()

	// 4. Write type aliases based on all discovered tasks
	g.generateTypeAliases()

	// 5. Write the actual conversion functions
	g.generateAllConversionFunctions()

	// 6. Generate custom stubs if any
	g.generateCustomStubs()

	return format.Source(g.buf.Bytes())
}

// CustomStubs returns the generated custom conversion stubs.
func (g *Generator) CustomStubs() []byte {
	if g.customBuf.Len() == 0 {
		return nil
	}
	formatted, err := format.Source(g.customBuf.Bytes())
	if err != nil {
		// Log the error but return unformatted bytes to allow inspection
		slog.Error("Error formatting custom stubs", "error", err)
		return g.customBuf.Bytes()
	}
	return formatted
}

func (g *Generator) addInitialTasks() {
	for _, pair := range g.config.Pairs {
		sourceInfo, _ := g.walker.Resolve(pair.Source.Type)
		targetInfo, _ := g.walker.Resolve(pair.Target.Type)
		if sourceInfo != nil && targetInfo != nil {
			// Assign LocalAlias if available from the TypeEndpoint
			if pair.Source.AliasType != "" {
				sourceInfo.LocalAlias = pair.Source.AliasType
			}
			if pair.Target.AliasType != "" {
				targetInfo.LocalAlias = pair.Target.AliasType
			}

			g.addTask(sourceInfo, targetInfo)
			if g.config.Direction == "both" {
				g.addTask(targetInfo, sourceInfo)
			}
		}
	}
}

func (g *Generator) addTask(source, target *types.TypeInfo) {
	taskKey := g.getTaskKey(source, target)
	if !g.generatedTasks[taskKey] {
		g.tasks = append(g.tasks, conversionTask{Source: source, Target: target})
		g.generatedTasks[taskKey] = true
	}
}

func (g *Generator) getTaskKey(source, target *types.TypeInfo) string {
	return source.ImportPath + "." + source.Name + "->" + target.ImportPath + "." + target.Name
}

// discoverAllTasks runs through the task queue to discover all sub-tasks without generating code.
func (g *Generator) discoverAllTasks() {
	for i := 0; i < len(g.tasks); i++ { // Loop expands as new tasks are added
		task := g.tasks[i]
		source, target := task.Source, task.Target

		// Only need to discover sub-tasks for struct-to-struct conversions
		if len(source.Fields) > 0 && len(target.Fields) > 0 {
			for _, field := range source.Fields {
				targetFieldName := field.Name
				if remap, ok := g.config.RemapFields[source.ImportPath+"."+source.Name+"#"+field.Name]; ok {
					targetFieldName = remap
				}
				if targetField, ok := findField(target.Fields, targetFieldName); ok {
					// If types are different, a sub-task is needed
					if field.Type != targetField.Type {
						sourceFieldType, _ := g.walker.Resolve(field.Type)
						targetFieldType, _ := g.walker.Resolve(targetField.Type)
						if sourceFieldType != nil && targetFieldType != nil {
							g.addTask(sourceFieldType, targetFieldType)
						}
					}
				}
			}
		}
	}
}

func (g *Generator) collectAndWriteImports() {
	for _, task := range g.tasks {
		g.addImportFromInfo(task.Source)
		g.addImportFromInfo(task.Target)
	}

	if len(g.imports.imports) == 0 {
		return
	}
	paths := make([]string, 0, len(g.imports.imports))
	for p := range g.imports.imports {
		paths = append(paths, p)
	}
	sort.Strings(paths)

	g.buf.WriteString("import (\n")
	for _, p := range paths {
		alias := g.imports.imports[p]
		g.buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, p))
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) generateTypeAliases() {
	aliasesToGenerate := make(map[string]string)

	allInfos := make(map[string]*types.TypeInfo)
	for _, task := range g.tasks {
		allInfos[g.getTaskKey(task.Source, task.Source)] = task.Source
		allInfos[g.getTaskKey(task.Target, task.Target)] = task.Target
	}

	for _, info := range allInfos {
		if g.isExternalType(info) {
			prefix, suffix := g.getPrefixSuffix(info)
			aliasName := g.getFuncNamePart(info, prefix, suffix) // e.g., "RoleBilateral" for types.Role
			fqn := info.ImportPath + "." + info.Name

			// Check if this alias is already defined in the directives.go file
			if existingFQN, ok := g.localTypeAliases[aliasName]; ok && existingFQN == fqn {
				// If the alias name and its FQN match a locally defined alias, skip generating it
				continue
			}

			if _, exists := aliasesToGenerate[fqn]; !exists {
				pkgAlias := g.imports.Add(info.ImportPath)
				aliasesToGenerate[fqn] = fmt.Sprintf("\t%s = %s.%s\n", aliasName, pkgAlias, info.Name)
				g.generatedAliases[fqn] = aliasName
			}
		}
	}

	if len(aliasesToGenerate) == 0 {
		return
	}

	g.buf.WriteString("// Local type aliases for external types.\n")
	g.buf.WriteString("type (\n")
	var sortedAliases []string
	for _, aliasDef := range aliasesToGenerate {
		sortedAliases = append(sortedAliases, aliasDef)
	}
	sort.Strings(sortedAliases)
	for _, aliasDef := range sortedAliases {
		g.buf.WriteString(aliasDef)
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) generateAllConversionFunctions() {
	// Sort tasks for consistent function generation order
	sort.Slice(g.tasks, func(i, j int) bool {
		return g.getTaskKey(g.tasks[i].Source, g.tasks[j].Target) < g.getTaskKey(g.tasks[j].Source, g.tasks[j].Target)
	})

	for _, task := range g.tasks {
		g.generateSingleConversionFunc(task.Source, task.Target)
	}
}

// isSliceType checks if a TypeInfo represents a slice type.
// It now directly uses the IsSlice field from TypeInfo.
func (g *Generator) isSliceType(info *types.TypeInfo) bool {
	if info == nil {
		return false
	}
	return info.IsSlice // Use TypeInfo.IsSlice directly
}

// getSliceElementType extracts the element type string and TypeInfo from a slice TypeInfo.
// It now directly uses the ElemType field from TypeInfo.
func (g *Generator) getSliceElementType(info *types.TypeInfo) (string, *types.TypeInfo) {
	if info == nil || !info.IsSlice || info.ElemType == nil {
		return "", nil
	}
	// The ElemType.Name should already be the base name (e.g., "UserPB")
	return info.ElemType.Name, info.ElemType
}

func (g *Generator) generateSingleConversionFunc(source, target *types.TypeInfo) {
	isSourceSlice := g.isSliceType(source)
	isTargetSlice := g.isSliceType(target)

	if isSourceSlice && isTargetSlice {
		sourceElemInfo := source.ElemType // Use ElemType directly
		targetElemInfo := target.ElemType // Use ElemType directly

		// Only generate slice-to-slice conversion if element types are structs
		// and they are not basic types (e.g., []int to []string should be handled by auto-conversion or custom)
		if sourceElemInfo != nil && targetElemInfo != nil && sourceElemInfo.IsStruct && targetElemInfo.IsStruct { // Use IsStruct
			g.generateSliceToSliceFunc(source, target, sourceElemInfo, targetElemInfo)
			return
		}
	}

	isSourceStruct := source.IsStruct // Use IsStruct directly
	isTargetStruct := target.IsStruct // Use IsStruct directly

	if isSourceStruct && isTargetStruct {
		g.generateStructToStructFunc(source, target)
	} else if g.canAutoConvert(source, target) {
		g.generateAutoConversionFunc(source, target)
	} else {
		taskKey := g.getTaskKey(source, target)
		g.customTasks[taskKey] = conversionTask{Source: source, Target: target}
	}
}

func (g *Generator) generateSliceToSliceFunc(sourceSlice, targetSlice, sourceElem, targetElem *types.TypeInfo) {
	sourcePrefix, sourceSuffix := g.getPrefixSuffix(sourceSlice)
	targetPrefix, targetSuffix := g.getPrefixSuffix(targetSlice)
	sourceNamePart := g.getFuncNamePart(sourceSlice, sourcePrefix, sourceSuffix)
	targetNamePart := g.getFuncNamePart(targetSlice, targetPrefix, targetSuffix)
	funcName := "Convert" + capitalize(sourceNamePart) + "To" + capitalize(targetNamePart)

	// Use the full type string for the function signature
	sourceTypeStr := g.getTypeName(sourceSlice)
	targetTypeStr := g.getTypeName(targetSlice)

	// NEW: Ensure slice parameters do not have an extra pointer, as slices are already reference types.
	// This is a defensive measure in case TypeInfo.Name or getTypeName incorrectly includes a leading '*'.
	sourceParam := strings.TrimPrefix(sourceTypeStr, "*")
	targetReturn := strings.TrimPrefix(targetTypeStr, "*")

	elemConvFuncName := g.getConversionFunctionName(sourceElem, targetElem)

	g.buf.WriteString(fmt.Sprintf("// %s converts a %s to a %s.\n", funcName, sourceTypeStr, targetTypeStr)) // Comment can still use original type strings
	g.buf.WriteString(fmt.Sprintf("func %s(from %s) %s {\n", funcName, sourceParam, targetReturn)) // Use trimmed parameters
	g.buf.WriteString("\tif from == nil {\n\t\treturn nil\n\t}\n")
	g.buf.WriteString(fmt.Sprintf("\tto := make(%s, len(from))\n", targetReturn)) // Use trimmed targetReturn for make
	g.buf.WriteString("\tfor i, item := range from {\n")
	g.buf.WriteString(fmt.Sprintf("\t\tto[i] = %s(item)\n", elemConvFuncName))
	g.buf.WriteString("\t}\n")
	g.buf.WriteString("\treturn to\n}\n\n")
}

func (g *Generator) generateStructToStructFunc(source, target *types.TypeInfo) {
	sourcePrefix, sourceSuffix := g.getPrefixSuffix(source)
	targetPrefix, targetSuffix := g.getPrefixSuffix(target)
	sourceNamePart := g.getFuncNamePart(source, sourcePrefix, sourceSuffix)
	targetNamePart := g.getFuncNamePart(target, targetPrefix, targetSuffix)
	funcName := "Convert" + capitalize(sourceNamePart) + "To" + capitalize(targetNamePart)

	sourceTypeStr := g.getTypeName(source)
	targetTypeStr := g.getTypeName(target)

	// Determine if we need pointers for function signature
	sourceParam := sourceTypeStr
	targetReturn := targetTypeStr

	// If it's a struct (not a slice), and not already a pointer, add a pointer.
	// This ensures struct-to-struct conversions return pointers.
	if source.IsStruct && !source.IsPointer {
		sourceParam = "*" + sourceTypeStr
	}
	if target.IsStruct && !target.IsPointer {
		targetReturn = "*" + targetTypeStr
	}

	g.buf.WriteString(fmt.Sprintf("// %s converts a %s to a %s.\n", funcName, sourceParam, targetReturn))
	g.buf.WriteString(fmt.Sprintf("func %s(from %s) %s {\n", funcName, sourceParam, targetReturn))

	if source.IsSlice { // Use info.IsSlice directly
		g.buf.WriteString("\tif from == nil {\n\t\treturn nil\n\t}\n")
		g.buf.WriteString(fmt.Sprintf("\tto := make(%s, len(from))\n", targetReturn))
		g.buf.WriteString("\tfor i, item := range from {\n")
		elemConvFuncName := g.getConversionFunctionName(source.ElemType, target.ElemType) // Use ElemType
		g.buf.WriteString(fmt.Sprintf("\t\tto[i] = %s(item)\n", elemConvFuncName))
		g.buf.WriteString("\t}\n")
	} else {
		g.buf.WriteString("\tif from == nil {\n\t\treturn nil\n\t}\n")
		// Create struct instance, always non-pointer, then take its address if targetReturn is a pointer
		toVar := strings.TrimPrefix(targetTypeStr, "*")
		g.buf.WriteString(fmt.Sprintf("\tto := &%s{}\n\n", toVar))
		for _, field := range source.Fields {
			g.handleFieldAssignment(field, source, target)
		}
	}

	g.buf.WriteString("\treturn to\n}\n\n")
}

func (g *Generator) handleFieldAssignment(sourceField types.StructField, sourceInfo, targetInfo *types.TypeInfo) {
	fqnField := sourceInfo.ImportPath + "." + sourceInfo.Name + "#" + sourceField.Name
	if g.config.IgnoreFields[fqnField] {
		return
	}
	targetFieldName := sourceField.Name
	if remap, ok := g.config.RemapFields[fqnField]; ok {
		targetFieldName = remap
	}
	targetField, ok := findField(targetInfo.Fields, targetFieldName)
	if !ok { // Corrected: if target field is NOT found, then return
		return
	}

	sourceFieldType := sourceField.Type // Use TypeInfo directly
	targetFieldType := targetField.Type // Use TypeInfo directly

	convFuncName := g.getConversionFunctionName(sourceFieldType, targetFieldType)

	sourceDeref := ""
	if sourceFieldType.IsPointer && isBasicType(sourceFieldType) { // Use TypeInfo.IsPointer
		sourceDeref = "*"
	}

	// Determine the assignment string
	var assignmentStr string
	if convFuncName == "" {
		// Case 1: Types are identical (including underlying types and pointer status).
		// This is the only case where convFuncName should be empty.
		assignmentStr = fmt.Sprintf("%sfrom.%s", sourceDeref, sourceField.Name)
	} else {
		// Case 2: Need a conversion. Check if it's a direct cast.
		if g.canDirectCast(sourceFieldType, targetFieldType) {
			assignmentStr = fmt.Sprintf("%s(%sfrom.%s)", targetFieldType.Name, sourceDeref, sourceField.Name)
		} else {
			// Case 3: Need a full conversion function call.
			assignmentStr = fmt.Sprintf("%s(%sfrom.%s)", convFuncName, sourceDeref, sourceField.Name)
		}
	}

	// NEW: If the target field is a struct pointer, and the assignment string is not already a pointer, add '&'.
	// This handles cases like `to.Parent = &ConvertDepartmentPBToDepartment(from.Parent)`
	if targetFieldType.IsStruct && targetFieldType.IsPointer && !strings.HasPrefix(assignmentStr, "&") && !strings.HasPrefix(assignmentStr, "*") {
		assignmentStr = "&" + assignmentStr
	}

	// Use targetField.Name to ensure correct capitalization for the target field
	g.buf.WriteString(fmt.Sprintf("\tto.%s = %s\n", targetField.Name, assignmentStr))
}

// getUnderlyingTypeInfo resolves the ultimate underlying type of a TypeInfo, handling aliases.
// It now directly uses the Underlying field from TypeInfo.
func (g *Generator) getUnderlyingTypeInfo(info *types.TypeInfo) *types.TypeInfo {
	if info == nil {
		return nil
	}
	if info.IsAlias && info.Underlying != nil {
		// Recursively get the ultimate underlying type
		return g.getUnderlyingTypeInfo(info.Underlying)
	}
	return info
}

// canDirectCast checks if a direct type cast is possible between two non-pointer basic number types.
func (g *Generator) canDirectCast(source, target *types.TypeInfo) bool {
	return !source.IsPointer && !target.IsPointer &&
		source.IsPrimitive && target.IsPrimitive && // Use IsPrimitive
		source.IsNumber && target.IsNumber // Use IsNumber
}

func (g *Generator) getConversionFunctionName(source, target *types.TypeInfo) string {
	// Resolve underlying types for comparison
	underlyingSource := g.getUnderlyingTypeInfo(source)
	underlyingTarget := g.getUnderlyingTypeInfo(target)

	// If underlying types are identical (including pointer status), it's a direct assignment.
	if underlyingSource.ImportPath == underlyingTarget.ImportPath &&
		underlyingSource.Name == underlyingTarget.Name &&
		underlyingSource.IsPointer == underlyingTarget.IsPointer {
		return "" // Direct assignment
	}

	// If both are slice types, get the conversion function for their elements
	if source.IsSlice && target.IsSlice { // Use info.IsSlice directly
		sourceElemInfo := source.ElemType // Use info.ElemType directly
		targetElemInfo := target.ElemType // Use info.ElemType directly

		if sourceElemInfo != nil && targetElemInfo != nil {
			// Get the base name of the element types (singular)
			// Pass empty prefix/suffix to get the raw base name for pluralization
			sourceElemBaseName := g.getFuncNamePart(sourceElemInfo, "", "")
			targetElemBaseName := g.getFuncNamePart(targetElemInfo, "", "")

			// Manually pluralize for the slice conversion function name
			pluralSourceElemName := sourceElemBaseName
			if !strings.HasSuffix(pluralSourceElemName, "s") { // Simple pluralization heuristic
				pluralSourceElemName += "s"
			}
			pluralTargetElemName := targetElemBaseName
			if !strings.HasSuffix(pluralTargetElemName, "s") { // Simple pluralization heuristic
				pluralTargetElemName += "s"
			}

			return "Convert" + capitalize(pluralSourceElemName) + "To" + capitalize(pluralTargetElemName)
		}
	}

	sourcePrefix, sourceSuffix := g.getPrefixSuffix(source)
	targetPrefix, targetSuffix := g.getPrefixSuffix(target)
	sourcePart := g.getFuncNamePart(source, sourcePrefix, sourceSuffix)
	targetPart := g.getFuncNamePart(target, targetPrefix, targetSuffix)

	return "Convert" + capitalize(sourcePart) + "To" + capitalize(targetPart)
}

func (g *Generator) getConversionFunctionSignature(source, target *types.TypeInfo) string {
	targetTypeStr := g.getTypeName(target)
	if isBasicType(target) && !target.IsPointer {
		return targetTypeStr
	}
	return "*" + targetTypeStr
}

func (g *Generator) canAutoConvert(source, target *types.TypeInfo) bool {
	s, t := source.Name, target.Name
	if source.ImportPath == "time" && t == "string" {
		return true
	}
	if s == "string" && target.ImportPath == "time" {
		return true
	}
	if types.IsNumberType(s) && t == "string" {
		return true
	}
	if s == "string" && types.IsNumberType(t) {
		return true
	}
	// RE-ADD: Number to number conversion (direct cast) for standalone functions.
	if !source.IsPointer && !target.IsPointer &&
		source.IsPrimitive && target.IsPrimitive && // Use IsPrimitive
		source.IsNumber && target.IsNumber { // Use IsNumber
		return true
	}
	return false
}

func (g *Generator) generateAutoConversionFunc(source, target *types.TypeInfo) {
	funcName := g.getConversionFunctionName(source, target)
	sourceTypeStr := g.getTypeName(source)
	targetTypeStr := g.getTypeName(target)

	g.buf.WriteString(fmt.Sprintf("// %s converts %s to %s.\n", funcName, sourceTypeStr, targetTypeStr))
	g.buf.WriteString(fmt.Sprintf("func %s(from %s) %s {\n", funcName, sourceTypeStr, targetTypeStr))

	switch {
	case source.ImportPath == "time" && target.Name == "string":
		g.imports.Add("time")
		g.buf.WriteString("\treturn from.Format(time.RFC3339)\n")
	case source.Name == "string" && target.ImportPath == "time":
		g.imports.Add("time")
		g.buf.WriteString("\tt, _ := time.Parse(time.RFC3339, from)\n")
		g.buf.WriteString("\treturn t\n")
	case source.Name == "string" && types.IsNumberType(target.Name):
		g.imports.Add("strconv")
		g.buf.WriteString(fmt.Sprintf("\ti, _ := strconv.Atoi(from)\n\treturn %s(i)\n", target.Name))
	case types.IsNumberType(source.Name) && target.Name == "string":
		g.imports.Add("strconv")
		g.buf.WriteString("\treturn strconv.Itoa(int(from))\n")
	// RE-ADD: Number to number conversion
	case !source.IsPointer && !target.IsPointer &&
		source.IsPrimitive && target.IsPrimitive && // Use IsPrimitive
		source.IsNumber && target.IsNumber { // Use IsNumber
		g.buf.WriteString(fmt.Sprintf("\treturn %s(from)\n", target.Name)) // Direct cast
	}

	g.buf.WriteString("}\n\n")
}

func (g *Generator) generateCustomStubs() {
	if len(g.customTasks) == 0 {
		return
	}
	pkgName := path.Base(g.config.ContextPackagePath)
	g.customBuf.WriteString("package " + pkgName + "\n\n")
	g.customBuf.WriteString("// Code generated by abgen. DO NOT EDIT.\n")
	g.customBuf.WriteString("// This file is meant to be edited by hand to implement custom conversions.\n\n")

	// Collect imports for custom stubs
	customImports := NewImportManager()
	for _, task := range g.customTasks {
		// Correctly add imports from task.Source and task.Target to customImports
		if task.Source != nil && task.Source.ImportPath != "" && task.Source.ImportPath != "builtin" && task.Source.ImportPath != g.config.ContextPackagePath {
			customImports.Add(task.Source.ImportPath)
		}
		if task.Target != nil && task.Target.ImportPath != "" && task.Target.ImportPath != "builtin" && task.Target.ImportPath != g.config.ContextPackagePath {
			customImports.Add(task.Target.ImportPath)
		}
	}

	if len(customImports.imports) > 0 {
		paths := make([]string, 0, len(customImports.imports))
		for p := range customImports.imports {
			paths = append(paths, p)
		}
		sort.Strings(paths)

		g.customBuf.WriteString("import (\n")
		for _, p := range paths {
			alias := customImports.imports[p]
			g.customBuf.WriteString(fmt.Sprintf("\t%s %q\n", alias, p))
		}
		g.customBuf.WriteString(")\n\n")
	}

	g.customBuf.WriteString("// --- Custom Conversion Stubs ---\n")
	g.customBuf.WriteString("// Implement these functions in this file.\n\n")

	for _, task := range g.customTasks {
		funcName := g.getConversionFunctionName(task.Source, task.Target)
		sourceTypeStr := g.getTypeName(task.Source)
		targetTypeStr := g.getTypeName(task.Target)

		g.customBuf.WriteString(fmt.Sprintf("// %s converts %s to %s.\n", funcName, sourceTypeStr, targetTypeStr))
		g.customBuf.WriteString(fmt.Sprintf("func %s(from %s) %s {\n", funcName, sourceTypeStr, targetTypeStr)) // Corrected: write to g.customBuf
		g.customBuf.WriteString(fmt.Sprintf("\t// TODO: Implement this custom conversion\n"))
		g.customBuf.WriteString(fmt.Sprintf("\tpanic(\"custom conversion not implemented: %s\")\n", funcName))
		g.customBuf.WriteString("}\n\n")
	}
}

func (g *Generator) addImportFromInfo(info *types.TypeInfo) {
	if info != nil && info.ImportPath != "" && info.ImportPath != "builtin" && info.ImportPath != g.config.ContextPackagePath {
		g.imports.Add(info.ImportPath)
	}
}

func (g *Generator) getPrefixSuffix(info *types.TypeInfo) (prefix, suffix string) {
	if info == nil {
		return "", ""
	}
	if info.ImportPath == g.config.Source.Package {
		return g.config.Source.Prefix, g.config.Source.Suffix
	}
	if info.ImportPath == g.config.Target.Package {
		return g.config.Target.Prefix, g.config.Target.Suffix
	}
	return "", ""
}

func (g *Generator) getFuncNamePart(typeInfo *types.TypeInfo, prefix, suffix string) string {
	name := typeInfo.Name

	// If it's a slice type, get the element name first
	if strings.HasPrefix(name, "[]") {
		name = strings.TrimPrefix(name, "[]")
	}
	if strings.HasPrefix(name, "*") {
		name = strings.TrimPrefix(name, "*")
	}

	// If LocalAlias exists and it's not a basic type, we should apply prefix/suffix
	// if they are configured for the target package
	if typeInfo.LocalAlias != "" {
		if !isBasicType(typeInfo) && (prefix != "" || suffix != "") {
			// Check if this type belongs to the target package and needs suffix
			if typeInfo.ImportPath == g.config.Target.Package {
				return typeInfo.LocalAlias
			}
			// For source types with alias, we might need to apply prefix/suffix
			baseAlias := typeInfo.LocalAlias
			if strings.HasPrefix(baseAlias, prefix) && strings.HasSuffix(baseAlias, suffix) {
				return baseAlias // Already has the prefix/suffix
			}
			// Remove any existing prefix/suffix from the local alias and apply new ones
			cleanName := strings.TrimPrefix(baseAlias, prefix)
			cleanName = strings.TrimSuffix(cleanName, suffix)
			return prefix + cleanName + suffix
		}
		return typeInfo.LocalAlias
	}

	if isBasicType(typeInfo) {
		return name
	}
	if prefix != "" || suffix != "" {
		return prefix + name + suffix
	}
	return name
}

func (g *Generator) getTypeName(typeInfo *types.TypeInfo) string {
	if typeInfo == nil {
		return ""
	}
	// If it's a local alias (defined in the directive file), use it directly
	if typeInfo.LocalAlias != "" {
		return typeInfo.LocalAlias
	}

	// If a generated alias exists for the FQN, use it
	fqn := typeInfo.ImportPath + "." + typeInfo.Name
	if alias, ok := g.generatedAliases[fqn]; ok {
		return alias
	}

	// If it's a slice, return the slice type name (e.g., "[]*MyType" or "[]MyType")
	if typeInfo.IsSlice {
		elemTypeName := g.getTypeName(typeInfo.ElemType) // Get the name of the element type
		if typeInfo.ElemType != nil && typeInfo.ElemType.IsPointer {
			return "[]*" + strings.TrimPrefix(elemTypeName, "*") // Ensure only one '*' for element
		}
		return "[]" + strings.TrimPrefix(elemTypeName, "*")
	}

	// For external types, add import and use package alias
	if g.isExternalType(typeInfo) {
		pkgAlias := g.imports.Add(typeInfo.ImportPath)
		typeName := typeInfo.Name
		if typeInfo.IsPointer {
			typeName = "*" + typeName
		}
		return pkgAlias + "." + typeName
	}

	// For internal types or basic types, just use the name
	typeName := typeInfo.Name
	if typeInfo.IsPointer {
		typeName = "*" + typeName
	}
	return typeName
}

func (g *Generator) findCustomRule(sourceType, targetType *types.TypeInfo) string {
	for _, rule := range g.config.CustomRules {
		if rule.SourceTypeName == sourceType.Name && rule.TargetTypeName == targetType.Name {
			return rule.ConvertFunc
		}
	}
	return ""
}

func (g *Generator) isExternalType(typeInfo *types.TypeInfo) bool {
	return typeInfo.ImportPath != "" && typeInfo.ImportPath != "builtin" && typeInfo.ImportPath != g.config.ContextPackagePath
}

func isBasicType(typeInfo *types.TypeInfo) bool {
	if typeInfo == nil {
		return false
	}
	return types.IsPrimitiveType(typeInfo.Name) && typeInfo.ImportPath == "builtin"
}

func capitalize(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func findField(fields []types.StructField, name string) (types.StructField, bool) {
	for _, field := range fields {
		if strings.EqualFold(field.Name, name) {
			return field, true
		}
	}
	return types.StructField{}, false
}

func splitFQN(fqn string) (pkgPath, typeName string) {
	lastDot := strings.LastIndex(fqn, ".")
	if lastDot == -1 {
		return "", fqn
	}
	return fqn[:lastDot], fqn[lastDot+1:]
}

type ImportManager struct {
	imports map[string]string
}

func NewImportManager() *ImportManager {
	return &ImportManager{imports: make(map[string]string)}
}

func (im *ImportManager) Add(importPath string) string {
	if alias, exists := im.imports[importPath]; exists {
		return alias
	}
	alias := path.Base(importPath)
	originalAlias := alias
	counter := 1
	for {
		isConflict := false
		for _, existingAlias := range im.imports {
			if existingAlias == alias {
				isConflict = true
				alias = originalAlias + strconv.Itoa(counter)
				counter++
				break
			}
		}
		if !isConflict {
			break
		}
	}
	im.imports[importPath] = alias
	return alias
}
