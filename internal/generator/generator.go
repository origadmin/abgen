// Package generator is responsible for generating the Go source code based on the
// analysis results from the analyzer and configuration from the config package.
package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"log/slog"
	"sort"

	"github.com/origadmin/abgen/internal/config"
	"github.com/origadmin/abgen/internal/model"
)

// Generator holds the state for code generation.
type Generator struct {
	config    *config.Config
	buf       bytes.Buffer
	importMgr *ImportManager
	converter *TypeConverter
	namer     *Namer
	processed map[string]bool
	aliasMap  map[string]string // Maps FQN to alias
}

// NewGenerator creates a new Generator instance.
func NewGenerator(config *config.Config) *Generator {
	return &Generator{
		config:    config,
		importMgr: NewImportManager(),
		converter: NewTypeConverter(),
		namer:     NewNamer(config),
		processed: make(map[string]bool),
		aliasMap:  make(map[string]string),
	}
}

// Generate produces the Go source code for the conversions. It takes the pre-analyzed type information.
func (g *Generator) Generate(typeInfos map[string]*model.TypeInfo) ([]byte, error) {
	slog.Debug("Generating code", "type_count", len(typeInfos), "rules", len(g.config.ConversionRules))
	for fqn, info := range typeInfos {
		slog.Debug("Type info received by generator", "fqn", fqn, "name", info.Name, "kind", info.Kind)
	}

	// 1. Populate aliases for all referenced types
	g.populateAliases(typeInfos)
	// 2. Generate the actual code
	g.buf.Reset()
	g.writePackageHeader()
	g.writeImports()
	g.writeAliases(typeInfos)
	g.writeConversionFunctions(typeInfos)

	// 4. Format and return
	return format.Source(g.buf.Bytes())
}

// CustomStubs generates custom conversion stubs for complex conversions.
func (g *Generator) CustomStubs() []byte {
	var stubBuf bytes.Buffer

	stubBuf.WriteString("package ")
	stubBuf.WriteString(g.getPackageName())
	stubBuf.WriteString("\n\n")
	stubBuf.WriteString("// Code generated by abgen for custom conversion stubs. DO NOT EDIT.\n\n")

	// Format the stub code
	formatted, err := format.Source(stubBuf.Bytes())
	if err != nil {
		slog.Warn("Failed to format custom stubs", "error", err)
		return stubBuf.Bytes()
	}
	return formatted
}

func (g *Generator) writePackageHeader() {
	pkgName := g.getPackageName()
	g.buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
	g.buf.WriteString("// Code generated by abgen. DO NOT EDIT.\n\n")
}

func (g *Generator) writeImports() {
	// The import manager is populated during alias and task discovery.
	imports := g.importMgr.GetAllImports()
	if len(imports) == 0 {
		return
	}
	g.buf.WriteString("import (\n")
	// Sort imports for consistent output
	sortedImports := make([]string, 0, len(imports))
	for _, importPath := range imports {
		sortedImports = append(sortedImports, importPath)
	}
	sort.Strings(sortedImports)

	for _, importPath := range sortedImports {
		alias := g.importMgr.GetAlias(importPath)
		g.buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, importPath))
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) writeAliases(typeInfos map[string]*model.TypeInfo) {
	if len(g.aliasMap) == 0 {
		return
	}
	g.buf.WriteString("// Local type aliases for external types.\n")
	g.buf.WriteString("type (\n")

	// To ensure consistent output, sort the aliases by alias name
	type aliasPair struct {
		aliasName string // The local alias name, e.g., "DepartmentPB"
		typeInfo  *model.TypeInfo
	}
	aliases := make([]aliasPair, 0, len(g.aliasMap))
	for fqn, alias := range g.aliasMap {
		typeInfo, exists := typeInfos[fqn]
		if !exists {
			slog.Warn("Type not found for alias", "fqn", fqn)
			continue
		}
		aliases = append(aliases, aliasPair{
			aliasName: alias,
			typeInfo:  typeInfo,
		})
	}

	sort.Slice(aliases, func(i, j int) bool {
		return aliases[i].aliasName < aliases[j].aliasName
	})

	for _, item := range aliases {
		// The right-hand side of the alias should be the fully qualified original type,
		// using the ImportManager's aliases for its package.
		originalTypeName := g.getTypeString(item.typeInfo)
		g.buf.WriteString(fmt.Sprintf("\t%s = %s\n", item.aliasName, originalTypeName))
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) writeConversionFunctions(typeInfos map[string]*model.TypeInfo) {
	// Sort rules to ensure consistent output
	rules := g.config.ConversionRules
	sort.Slice(rules, func(i, j int) bool {
		return rules[i].SourceType < rules[j].SourceType
	})

	for _, rule := range rules {
		sourceInfo, sourceExists := typeInfos[rule.SourceType]
		targetInfo, targetExists := typeInfos[rule.TargetType]

		if !sourceExists {
			slog.Warn("Source type not found", "type", rule.SourceType)
			continue
		}
		if !targetExists {
			slog.Warn("Target type not found", "type", rule.TargetType)
			continue
		}

		g.generateConversionFunction(sourceInfo, targetInfo, rule)
	}
}

// Helper methods
func (g *Generator) getPackageName() string {
	if g.config.GenerationContext.PackageName != "" {
		return g.config.GenerationContext.PackageName
	}
	return "generated"
}

func (g *Generator) isCurrentPackage(importPath string) bool {
	return importPath == g.config.GenerationContext.PackagePath
}

func (g *Generator) getTypeString(info *model.TypeInfo) string {
	if info == nil {
		return "interface{}"
	}

	if info.IsNamedType() {
		pkgAlias := g.importMgr.GetAlias(info.ImportPath)
		return pkgAlias + "." + info.Name
	}

	return info.GoTypeString()
}

func (g *Generator) generateConversionFunction(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule) {
	funcName := g.namer.GetFunctionName(sourceInfo, targetInfo)

	g.buf.WriteString(fmt.Sprintf("// %s converts %s to %s\n", funcName, sourceInfo.FQN(), targetInfo.FQN()))
	g.buf.WriteString(fmt.Sprintf("func %s(source %s) %s {\n", funcName, g.getTypeString(sourceInfo), g.getTypeString(targetInfo)))

	if g.converter.IsStruct(sourceInfo) && g.converter.IsStruct(targetInfo) {
		g.generateStructToStructConversion(sourceInfo, targetInfo, rule)
	} else if g.converter.IsSlice(sourceInfo) && g.converter.IsSlice(targetInfo) {
		g.generateSliceToSliceConversion(sourceInfo, targetInfo, rule)
	} else {
		// Default simple conversion
		g.buf.WriteString("\treturn target\n")
	}

	g.buf.WriteString("}\n\n")
}

func (g *Generator) generateStructToStructConversion(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule) {
	g.buf.WriteString("\ttarget := " + g.getTypeString(targetInfo) + "{\n")

	// Generate field assignments
	for _, sourceField := range sourceInfo.Fields {
		// Check if field should be ignored
		if _, shouldIgnore := rule.FieldRules.Ignore[sourceField.Name]; shouldIgnore {
			continue
		}

		// Check if field should be remapped
		targetFieldName := sourceField.Name
		if remappedName, shouldRemap := rule.FieldRules.Remap[sourceField.Name]; shouldRemap {
			targetFieldName = remappedName
		}

		// Find corresponding target field
		var targetField *model.FieldInfo
		for _, tf := range targetInfo.Fields {
			if tf.Name == targetFieldName {
				targetField = tf
				break
			}
		}

		if targetField != nil {
			g.buf.WriteString(fmt.Sprintf("\t\t%s: source.%s,\n", targetFieldName, sourceField.Name))
		}
	}

	g.buf.WriteString("\t}\n")
	g.buf.WriteString("\treturn target\n")
}

func (g *Generator) generateSliceToSliceConversion(sourceInfo, targetInfo *model.TypeInfo, rule *config.ConversionRule) {
	sourceElem := g.converter.GetElementType(sourceInfo)
	targetElem := g.converter.GetElementType(targetInfo)

	if sourceElem != nil && targetElem != nil {
		funcName := g.namer.GetFunctionName(sourceElem, targetElem)
		g.buf.WriteString("\tif source == nil {\n")
		g.buf.WriteString("\t\treturn nil\n")
		g.buf.WriteString("\t}\n")
		g.buf.WriteString("\ttarget := make(" + g.getTypeString(targetInfo) + ", len(source))\n")
		g.buf.WriteString("\tfor i, item := range source {\n")
		g.buf.WriteString("\t\ttarget[i] = " + funcName + "(item)\n")
		g.buf.WriteString("\t}\n")
		g.buf.WriteString("\treturn target\n")
	} else {
		g.buf.WriteString("\treturn target\n")
	}
}

// populateAliases populates the aliasMap with all referenced types from conversion rules.
func (g *Generator) populateAliases(typeInfos map[string]*model.TypeInfo) {
	slog.Debug("populateAliases", "conversionRules", len(g.config.ConversionRules))

	// Create aliases for all packages defined in config
	for _, importPath := range g.config.PackageAliases {
		g.importMgr.Add(importPath)
	}

	// Process all conversion rules to create type aliases
	for _, rule := range g.config.ConversionRules {
		slog.Debug("Processing rule", "source", rule.SourceType, "target", rule.TargetType)

		// Add source and target types to aliases map
		sourceInfo, sourceExists := typeInfos[rule.SourceType]
		targetInfo, targetExists := typeInfos[rule.TargetType]

		if sourceExists && sourceInfo.IsNamedType() {
			sourceAlias := g.namer.GetTypeName(sourceInfo)
			g.aliasMap[rule.SourceType] = sourceAlias
			slog.Debug("Added source alias", "fqn", rule.SourceType, "alias", sourceAlias)
		} else {
			slog.Debug("Source type not found", "fqn", rule.SourceType, "exists", sourceExists, "named", sourceExists && sourceInfo.IsNamedType())
		}

		if targetExists && targetInfo.IsNamedType() {
			targetAlias := g.namer.GetTypeName(targetInfo)
			g.aliasMap[rule.TargetType] = targetAlias
			slog.Debug("Added target alias", "fqn", rule.TargetType, "alias", targetAlias)
		} else {
			slog.Debug("Target type not found", "fqn", rule.TargetType, "exists", targetExists, "named", targetExists && targetInfo.IsNamedType())
		}
	}

	slog.Debug("Final aliasMap", "size", len(g.aliasMap))
	for fqn, alias := range g.aliasMap {
		slog.Debug("Alias", "fqn", fqn, "alias", alias)
	}

	// Add all referenced types to import manager
	for _, typeInfo := range typeInfos {
		if typeInfo.IsNamedType() && typeInfo.ImportPath != "" && !g.isCurrentPackage(typeInfo.ImportPath) {
			g.importMgr.Add(typeInfo.ImportPath)
		}
	}
}
